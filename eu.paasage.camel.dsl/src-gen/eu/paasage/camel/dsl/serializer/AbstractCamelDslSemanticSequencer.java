/*
 * generated by Xtext
 */
package eu.paasage.camel.dsl.serializer;

import com.google.inject.Inject;
import eu.paasage.camel.Application;
import eu.paasage.camel.CamelModel;
import eu.paasage.camel.CamelPackage;
import eu.paasage.camel.deployment.Communication;
import eu.paasage.camel.deployment.CommunicationInstance;
import eu.paasage.camel.deployment.Configuration;
import eu.paasage.camel.deployment.DeploymentModel;
import eu.paasage.camel.deployment.DeploymentPackage;
import eu.paasage.camel.deployment.Hosting;
import eu.paasage.camel.deployment.HostingInstance;
import eu.paasage.camel.deployment.InternalComponent;
import eu.paasage.camel.deployment.InternalComponentInstance;
import eu.paasage.camel.deployment.ProvidedCommunication;
import eu.paasage.camel.deployment.ProvidedCommunicationInstance;
import eu.paasage.camel.deployment.ProvidedHost;
import eu.paasage.camel.deployment.ProvidedHostInstance;
import eu.paasage.camel.deployment.RequiredCommunication;
import eu.paasage.camel.deployment.RequiredCommunicationInstance;
import eu.paasage.camel.deployment.RequiredHost;
import eu.paasage.camel.deployment.RequiredHostInstance;
import eu.paasage.camel.deployment.VM;
import eu.paasage.camel.deployment.VMInstance;
import eu.paasage.camel.deployment.VMRequirementSet;
import eu.paasage.camel.dsl.services.CamelDslGrammarAccess;
import eu.paasage.camel.execution.ActionRealisation;
import eu.paasage.camel.execution.ApplicationMeasurement;
import eu.paasage.camel.execution.CommunicationMeasurement;
import eu.paasage.camel.execution.ExecutionContext;
import eu.paasage.camel.execution.ExecutionModel;
import eu.paasage.camel.execution.ExecutionPackage;
import eu.paasage.camel.execution.InternalComponentMeasurement;
import eu.paasage.camel.execution.RuleTrigger;
import eu.paasage.camel.execution.SLOAssessment;
import eu.paasage.camel.execution.VMMeasurement;
import eu.paasage.camel.location.CloudLocation;
import eu.paasage.camel.location.Country;
import eu.paasage.camel.location.GeographicalRegion;
import eu.paasage.camel.location.LocationModel;
import eu.paasage.camel.location.LocationPackage;
import eu.paasage.camel.metric.CompositeMetric;
import eu.paasage.camel.metric.CompositeMetricContext;
import eu.paasage.camel.metric.CompositeMetricInstance;
import eu.paasage.camel.metric.MetricApplicationBinding;
import eu.paasage.camel.metric.MetricComponentBinding;
import eu.paasage.camel.metric.MetricCondition;
import eu.paasage.camel.metric.MetricFormula;
import eu.paasage.camel.metric.MetricFormulaParameter;
import eu.paasage.camel.metric.MetricModel;
import eu.paasage.camel.metric.MetricPackage;
import eu.paasage.camel.metric.MetricVMBinding;
import eu.paasage.camel.metric.Property;
import eu.paasage.camel.metric.PropertyCondition;
import eu.paasage.camel.metric.PropertyContext;
import eu.paasage.camel.metric.RawMetric;
import eu.paasage.camel.metric.RawMetricContext;
import eu.paasage.camel.metric.RawMetricInstance;
import eu.paasage.camel.metric.Schedule;
import eu.paasage.camel.metric.Sensor;
import eu.paasage.camel.metric.Window;
import eu.paasage.camel.organisation.CloudCredentials;
import eu.paasage.camel.organisation.CloudProvider;
import eu.paasage.camel.organisation.DataCenter;
import eu.paasage.camel.organisation.Entity;
import eu.paasage.camel.organisation.ExternalIdentifier;
import eu.paasage.camel.organisation.InformationResourceFilter;
import eu.paasage.camel.organisation.Organisation;
import eu.paasage.camel.organisation.OrganisationModel;
import eu.paasage.camel.organisation.OrganisationPackage;
import eu.paasage.camel.organisation.PaaSageCredentials;
import eu.paasage.camel.organisation.Permission;
import eu.paasage.camel.organisation.Role;
import eu.paasage.camel.organisation.RoleAssignment;
import eu.paasage.camel.organisation.ServiceResourceFilter;
import eu.paasage.camel.organisation.User;
import eu.paasage.camel.organisation.UserGroup;
import eu.paasage.camel.provider.Alternative;
import eu.paasage.camel.provider.Attribute;
import eu.paasage.camel.provider.AttributeConstraint;
import eu.paasage.camel.provider.Clone;
import eu.paasage.camel.provider.Excludes;
import eu.paasage.camel.provider.Exclusive;
import eu.paasage.camel.provider.FeatCardinality;
import eu.paasage.camel.provider.Feature;
import eu.paasage.camel.provider.Functional;
import eu.paasage.camel.provider.GroupCardinality;
import eu.paasage.camel.provider.Implies;
import eu.paasage.camel.provider.Instance;
import eu.paasage.camel.provider.Product;
import eu.paasage.camel.provider.ProviderModel;
import eu.paasage.camel.provider.ProviderPackage;
import eu.paasage.camel.provider.Requires;
import eu.paasage.camel.requirement.HorizontalScaleRequirement;
import eu.paasage.camel.requirement.ImageRequirement;
import eu.paasage.camel.requirement.LocationRequirement;
import eu.paasage.camel.requirement.OSRequirement;
import eu.paasage.camel.requirement.OptimisationRequirement;
import eu.paasage.camel.requirement.ProviderRequirement;
import eu.paasage.camel.requirement.QualitativeHardwareRequirement;
import eu.paasage.camel.requirement.QuantitativeHardwareRequirement;
import eu.paasage.camel.requirement.RequirementGroup;
import eu.paasage.camel.requirement.RequirementModel;
import eu.paasage.camel.requirement.RequirementPackage;
import eu.paasage.camel.requirement.SecurityRequirement;
import eu.paasage.camel.requirement.ServiceLevelObjective;
import eu.paasage.camel.requirement.VerticalScaleRequirement;
import eu.paasage.camel.scalability.BinaryEventPattern;
import eu.paasage.camel.scalability.EventInstance;
import eu.paasage.camel.scalability.FunctionalEvent;
import eu.paasage.camel.scalability.HorizontalScalingAction;
import eu.paasage.camel.scalability.NonFunctionalEvent;
import eu.paasage.camel.scalability.ScalabilityModel;
import eu.paasage.camel.scalability.ScalabilityPackage;
import eu.paasage.camel.scalability.ScalabilityRule;
import eu.paasage.camel.scalability.Timer;
import eu.paasage.camel.scalability.UnaryEventPattern;
import eu.paasage.camel.scalability.VerticalScalingAction;
import eu.paasage.camel.security.Certifiable;
import eu.paasage.camel.security.CompositeSecurityMetric;
import eu.paasage.camel.security.CompositeSecurityMetricInstance;
import eu.paasage.camel.security.RawSecurityMetric;
import eu.paasage.camel.security.RawSecurityMetricInstance;
import eu.paasage.camel.security.SecurityCapability;
import eu.paasage.camel.security.SecurityControl;
import eu.paasage.camel.security.SecurityDomain;
import eu.paasage.camel.security.SecurityModel;
import eu.paasage.camel.security.SecurityPackage;
import eu.paasage.camel.security.SecurityProperty;
import eu.paasage.camel.security.SecuritySLO;
import eu.paasage.camel.type.BoolValue;
import eu.paasage.camel.type.BooleanValueType;
import eu.paasage.camel.type.DoublePrecisionValue;
import eu.paasage.camel.type.EnumerateValue;
import eu.paasage.camel.type.Enumeration;
import eu.paasage.camel.type.FloatsValue;
import eu.paasage.camel.type.IntegerValue;
import eu.paasage.camel.type.Limit;
import eu.paasage.camel.type.List;
import eu.paasage.camel.type.NegativeInf;
import eu.paasage.camel.type.PositiveInf;
import eu.paasage.camel.type.Range;
import eu.paasage.camel.type.RangeUnion;
import eu.paasage.camel.type.StringValueType;
import eu.paasage.camel.type.StringsValue;
import eu.paasage.camel.type.TypeModel;
import eu.paasage.camel.type.TypePackage;
import eu.paasage.camel.type.ValueToIncrease;
import eu.paasage.camel.unit.CoreUnit;
import eu.paasage.camel.unit.Dimensionless;
import eu.paasage.camel.unit.MonetaryUnit;
import eu.paasage.camel.unit.RequestUnit;
import eu.paasage.camel.unit.StorageUnit;
import eu.paasage.camel.unit.ThroughputUnit;
import eu.paasage.camel.unit.TimeIntervalUnit;
import eu.paasage.camel.unit.TransactionUnit;
import eu.paasage.camel.unit.UnitModel;
import eu.paasage.camel.unit.UnitPackage;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractCamelDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CamelDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CamelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CamelPackage.ACTION:
				sequence_Action(context, (eu.paasage.camel.Action) semanticObject); 
				return; 
			case CamelPackage.APPLICATION:
				sequence_Application(context, (Application) semanticObject); 
				return; 
			case CamelPackage.CAMEL_MODEL:
				sequence_CamelModel(context, (CamelModel) semanticObject); 
				return; 
			}
		else if (epackage == DeploymentPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DeploymentPackage.COMMUNICATION:
				sequence_Communication(context, (Communication) semanticObject); 
				return; 
			case DeploymentPackage.COMMUNICATION_INSTANCE:
				sequence_CommunicationInstance(context, (CommunicationInstance) semanticObject); 
				return; 
			case DeploymentPackage.CONFIGURATION:
				sequence_Configuration(context, (Configuration) semanticObject); 
				return; 
			case DeploymentPackage.DEPLOYMENT_MODEL:
				sequence_DeploymentModel(context, (DeploymentModel) semanticObject); 
				return; 
			case DeploymentPackage.HOSTING:
				sequence_Hosting(context, (Hosting) semanticObject); 
				return; 
			case DeploymentPackage.HOSTING_INSTANCE:
				sequence_HostingInstance(context, (HostingInstance) semanticObject); 
				return; 
			case DeploymentPackage.INTERNAL_COMPONENT:
				sequence_InternalComponent(context, (InternalComponent) semanticObject); 
				return; 
			case DeploymentPackage.INTERNAL_COMPONENT_INSTANCE:
				sequence_InternalComponentInstance(context, (InternalComponentInstance) semanticObject); 
				return; 
			case DeploymentPackage.PROVIDED_COMMUNICATION:
				sequence_ProvidedCommunication(context, (ProvidedCommunication) semanticObject); 
				return; 
			case DeploymentPackage.PROVIDED_COMMUNICATION_INSTANCE:
				sequence_ProvidedCommunicationInstance(context, (ProvidedCommunicationInstance) semanticObject); 
				return; 
			case DeploymentPackage.PROVIDED_HOST:
				sequence_ProvidedHost(context, (ProvidedHost) semanticObject); 
				return; 
			case DeploymentPackage.PROVIDED_HOST_INSTANCE:
				sequence_ProvidedHostInstance(context, (ProvidedHostInstance) semanticObject); 
				return; 
			case DeploymentPackage.REQUIRED_COMMUNICATION:
				sequence_RequiredCommunication(context, (RequiredCommunication) semanticObject); 
				return; 
			case DeploymentPackage.REQUIRED_COMMUNICATION_INSTANCE:
				sequence_RequiredCommunicationInstance(context, (RequiredCommunicationInstance) semanticObject); 
				return; 
			case DeploymentPackage.REQUIRED_HOST:
				sequence_RequiredHost(context, (RequiredHost) semanticObject); 
				return; 
			case DeploymentPackage.REQUIRED_HOST_INSTANCE:
				sequence_RequiredHostInstance(context, (RequiredHostInstance) semanticObject); 
				return; 
			case DeploymentPackage.VM:
				sequence_VM(context, (VM) semanticObject); 
				return; 
			case DeploymentPackage.VM_INSTANCE:
				sequence_VMInstance(context, (VMInstance) semanticObject); 
				return; 
			case DeploymentPackage.VM_REQUIREMENT_SET:
				sequence_VMRequirementSet(context, (VMRequirementSet) semanticObject); 
				return; 
			}
		else if (epackage == ExecutionPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ExecutionPackage.ACTION_REALISATION:
				sequence_ActionRealisation(context, (ActionRealisation) semanticObject); 
				return; 
			case ExecutionPackage.APPLICATION_MEASUREMENT:
				sequence_ApplicationMeasurement(context, (ApplicationMeasurement) semanticObject); 
				return; 
			case ExecutionPackage.COMMUNICATION_MEASUREMENT:
				sequence_CommunicationMeasurement(context, (CommunicationMeasurement) semanticObject); 
				return; 
			case ExecutionPackage.EXECUTION_CONTEXT:
				sequence_ExecutionContext(context, (ExecutionContext) semanticObject); 
				return; 
			case ExecutionPackage.EXECUTION_MODEL:
				sequence_ExecutionModel(context, (ExecutionModel) semanticObject); 
				return; 
			case ExecutionPackage.INTERNAL_COMPONENT_MEASUREMENT:
				sequence_InternalComponentMeasurement(context, (InternalComponentMeasurement) semanticObject); 
				return; 
			case ExecutionPackage.RULE_TRIGGER:
				sequence_RuleTrigger(context, (RuleTrigger) semanticObject); 
				return; 
			case ExecutionPackage.SLO_ASSESSMENT:
				sequence_SLOAssessment(context, (SLOAssessment) semanticObject); 
				return; 
			case ExecutionPackage.VM_MEASUREMENT:
				sequence_VMMeasurement(context, (VMMeasurement) semanticObject); 
				return; 
			}
		else if (epackage == LocationPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case LocationPackage.CLOUD_LOCATION:
				sequence_CloudLocation(context, (CloudLocation) semanticObject); 
				return; 
			case LocationPackage.COUNTRY:
				sequence_Country(context, (Country) semanticObject); 
				return; 
			case LocationPackage.GEOGRAPHICAL_REGION:
				sequence_GeographicalRegion(context, (GeographicalRegion) semanticObject); 
				return; 
			case LocationPackage.LOCATION_MODEL:
				sequence_LocationModel(context, (LocationModel) semanticObject); 
				return; 
			}
		else if (epackage == MetricPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MetricPackage.COMPOSITE_METRIC:
				sequence_CompositeMetric(context, (CompositeMetric) semanticObject); 
				return; 
			case MetricPackage.COMPOSITE_METRIC_CONTEXT:
				sequence_CompositeMetricContext(context, (CompositeMetricContext) semanticObject); 
				return; 
			case MetricPackage.COMPOSITE_METRIC_INSTANCE:
				sequence_CompositeMetricInstance(context, (CompositeMetricInstance) semanticObject); 
				return; 
			case MetricPackage.METRIC_APPLICATION_BINDING:
				sequence_MetricApplicationBinding(context, (MetricApplicationBinding) semanticObject); 
				return; 
			case MetricPackage.METRIC_COMPONENT_BINDING:
				sequence_MetricComponentBinding(context, (MetricComponentBinding) semanticObject); 
				return; 
			case MetricPackage.METRIC_CONDITION:
				sequence_MetricCondition(context, (MetricCondition) semanticObject); 
				return; 
			case MetricPackage.METRIC_FORMULA:
				sequence_MetricFormula(context, (MetricFormula) semanticObject); 
				return; 
			case MetricPackage.METRIC_FORMULA_PARAMETER:
				sequence_MetricFormulaParameter_Impl(context, (MetricFormulaParameter) semanticObject); 
				return; 
			case MetricPackage.METRIC_MODEL:
				sequence_MetricModel(context, (MetricModel) semanticObject); 
				return; 
			case MetricPackage.METRIC_VM_BINDING:
				sequence_MetricVMBinding(context, (MetricVMBinding) semanticObject); 
				return; 
			case MetricPackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			case MetricPackage.PROPERTY_CONDITION:
				sequence_PropertyCondition(context, (PropertyCondition) semanticObject); 
				return; 
			case MetricPackage.PROPERTY_CONTEXT:
				sequence_PropertyContext(context, (PropertyContext) semanticObject); 
				return; 
			case MetricPackage.RAW_METRIC:
				sequence_RawMetric(context, (RawMetric) semanticObject); 
				return; 
			case MetricPackage.RAW_METRIC_CONTEXT:
				sequence_RawMetricContext(context, (RawMetricContext) semanticObject); 
				return; 
			case MetricPackage.RAW_METRIC_INSTANCE:
				sequence_RawMetricInstance(context, (RawMetricInstance) semanticObject); 
				return; 
			case MetricPackage.SCHEDULE:
				sequence_Schedule(context, (Schedule) semanticObject); 
				return; 
			case MetricPackage.SENSOR:
				sequence_Sensor(context, (Sensor) semanticObject); 
				return; 
			case MetricPackage.WINDOW:
				sequence_Window(context, (Window) semanticObject); 
				return; 
			}
		else if (epackage == OrganisationPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case OrganisationPackage.CLOUD_CREDENTIALS:
				sequence_CloudCredentials(context, (CloudCredentials) semanticObject); 
				return; 
			case OrganisationPackage.CLOUD_PROVIDER:
				sequence_CloudProvider(context, (CloudProvider) semanticObject); 
				return; 
			case OrganisationPackage.DATA_CENTER:
				sequence_DataCenter(context, (DataCenter) semanticObject); 
				return; 
			case OrganisationPackage.ENTITY:
				sequence_Entity_Impl(context, (Entity) semanticObject); 
				return; 
			case OrganisationPackage.EXTERNAL_IDENTIFIER:
				sequence_ExternalIdentifier(context, (ExternalIdentifier) semanticObject); 
				return; 
			case OrganisationPackage.INFORMATION_RESOURCE_FILTER:
				sequence_InformationResourceFilter(context, (InformationResourceFilter) semanticObject); 
				return; 
			case OrganisationPackage.ORGANISATION:
				sequence_Organisation_Impl(context, (Organisation) semanticObject); 
				return; 
			case OrganisationPackage.ORGANISATION_MODEL:
				sequence_OrganisationModel(context, (OrganisationModel) semanticObject); 
				return; 
			case OrganisationPackage.PAA_SAGE_CREDENTIALS:
				sequence_PaaSageCredentials(context, (PaaSageCredentials) semanticObject); 
				return; 
			case OrganisationPackage.PERMISSION:
				sequence_Permission(context, (Permission) semanticObject); 
				return; 
			case OrganisationPackage.ROLE:
				sequence_Role(context, (Role) semanticObject); 
				return; 
			case OrganisationPackage.ROLE_ASSIGNMENT:
				sequence_RoleAssignment(context, (RoleAssignment) semanticObject); 
				return; 
			case OrganisationPackage.SERVICE_RESOURCE_FILTER:
				sequence_ServiceResourceFilter(context, (ServiceResourceFilter) semanticObject); 
				return; 
			case OrganisationPackage.USER:
				sequence_User(context, (User) semanticObject); 
				return; 
			case OrganisationPackage.USER_GROUP:
				sequence_UserGroup(context, (UserGroup) semanticObject); 
				return; 
			}
		else if (epackage == ProviderPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ProviderPackage.ALTERNATIVE:
				sequence_Alternative_Impl(context, (Alternative) semanticObject); 
				return; 
			case ProviderPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case ProviderPackage.ATTRIBUTE_CONSTRAINT:
				sequence_AttributeConstraint(context, (AttributeConstraint) semanticObject); 
				return; 
			case ProviderPackage.CLONE:
				sequence_Clone(context, (Clone) semanticObject); 
				return; 
			case ProviderPackage.EXCLUDES:
				sequence_Excludes(context, (Excludes) semanticObject); 
				return; 
			case ProviderPackage.EXCLUSIVE:
				sequence_Exclusive(context, (Exclusive) semanticObject); 
				return; 
			case ProviderPackage.FEAT_CARDINALITY:
				sequence_FeatCardinality(context, (FeatCardinality) semanticObject); 
				return; 
			case ProviderPackage.FEATURE:
				sequence_Feature_Impl(context, (Feature) semanticObject); 
				return; 
			case ProviderPackage.FUNCTIONAL:
				sequence_Functional(context, (Functional) semanticObject); 
				return; 
			case ProviderPackage.GROUP_CARDINALITY:
				sequence_GroupCardinality(context, (GroupCardinality) semanticObject); 
				return; 
			case ProviderPackage.IMPLIES:
				sequence_Implies(context, (Implies) semanticObject); 
				return; 
			case ProviderPackage.INSTANCE:
				sequence_Instance(context, (Instance) semanticObject); 
				return; 
			case ProviderPackage.PRODUCT:
				sequence_Product(context, (Product) semanticObject); 
				return; 
			case ProviderPackage.PROVIDER_MODEL:
				sequence_ProviderModel(context, (ProviderModel) semanticObject); 
				return; 
			case ProviderPackage.REQUIRES:
				sequence_Requires_Impl(context, (Requires) semanticObject); 
				return; 
			}
		else if (epackage == RequirementPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RequirementPackage.HORIZONTAL_SCALE_REQUIREMENT:
				sequence_HorizontalScaleRequirement(context, (HorizontalScaleRequirement) semanticObject); 
				return; 
			case RequirementPackage.IMAGE_REQUIREMENT:
				sequence_ImageRequirement(context, (ImageRequirement) semanticObject); 
				return; 
			case RequirementPackage.LOCATION_REQUIREMENT:
				sequence_LocationRequirement(context, (LocationRequirement) semanticObject); 
				return; 
			case RequirementPackage.OS_REQUIREMENT:
				sequence_OSRequirement(context, (OSRequirement) semanticObject); 
				return; 
			case RequirementPackage.OPTIMISATION_REQUIREMENT:
				sequence_OptimisationRequirement(context, (OptimisationRequirement) semanticObject); 
				return; 
			case RequirementPackage.PROVIDER_REQUIREMENT:
				sequence_ProviderRequirement(context, (ProviderRequirement) semanticObject); 
				return; 
			case RequirementPackage.QUALITATIVE_HARDWARE_REQUIREMENT:
				sequence_QualitativeHardwareRequirement(context, (QualitativeHardwareRequirement) semanticObject); 
				return; 
			case RequirementPackage.QUANTITATIVE_HARDWARE_REQUIREMENT:
				sequence_QuantitativeHardwareRequirement(context, (QuantitativeHardwareRequirement) semanticObject); 
				return; 
			case RequirementPackage.REQUIREMENT_GROUP:
				sequence_RequirementGroup(context, (RequirementGroup) semanticObject); 
				return; 
			case RequirementPackage.REQUIREMENT_MODEL:
				sequence_RequirementModel(context, (RequirementModel) semanticObject); 
				return; 
			case RequirementPackage.SECURITY_REQUIREMENT:
				sequence_SecurityRequirement(context, (SecurityRequirement) semanticObject); 
				return; 
			case RequirementPackage.SERVICE_LEVEL_OBJECTIVE:
				sequence_ServiceLevelObjective(context, (ServiceLevelObjective) semanticObject); 
				return; 
			case RequirementPackage.VERTICAL_SCALE_REQUIREMENT:
				sequence_VerticalScaleRequirement(context, (VerticalScaleRequirement) semanticObject); 
				return; 
			}
		else if (epackage == ScalabilityPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ScalabilityPackage.BINARY_EVENT_PATTERN:
				sequence_BinaryEventPattern(context, (BinaryEventPattern) semanticObject); 
				return; 
			case ScalabilityPackage.EVENT_INSTANCE:
				sequence_EventInstance(context, (EventInstance) semanticObject); 
				return; 
			case ScalabilityPackage.FUNCTIONAL_EVENT:
				sequence_FunctionalEvent(context, (FunctionalEvent) semanticObject); 
				return; 
			case ScalabilityPackage.HORIZONTAL_SCALING_ACTION:
				sequence_HorizontalScalingAction(context, (HorizontalScalingAction) semanticObject); 
				return; 
			case ScalabilityPackage.NON_FUNCTIONAL_EVENT:
				sequence_NonFunctionalEvent(context, (NonFunctionalEvent) semanticObject); 
				return; 
			case ScalabilityPackage.SCALABILITY_MODEL:
				sequence_ScalabilityModel(context, (ScalabilityModel) semanticObject); 
				return; 
			case ScalabilityPackage.SCALABILITY_RULE:
				sequence_ScalabilityRule(context, (ScalabilityRule) semanticObject); 
				return; 
			case ScalabilityPackage.TIMER:
				sequence_Timer(context, (Timer) semanticObject); 
				return; 
			case ScalabilityPackage.UNARY_EVENT_PATTERN:
				sequence_UnaryEventPattern(context, (UnaryEventPattern) semanticObject); 
				return; 
			case ScalabilityPackage.VERTICAL_SCALING_ACTION:
				sequence_VerticalScalingAction(context, (VerticalScalingAction) semanticObject); 
				return; 
			}
		else if (epackage == SecurityPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SecurityPackage.CERTIFIABLE:
				sequence_Certifiable(context, (Certifiable) semanticObject); 
				return; 
			case SecurityPackage.COMPOSITE_SECURITY_METRIC:
				sequence_CompositeSecurityMetric(context, (CompositeSecurityMetric) semanticObject); 
				return; 
			case SecurityPackage.COMPOSITE_SECURITY_METRIC_INSTANCE:
				sequence_CompositeSecurityMetricInstance(context, (CompositeSecurityMetricInstance) semanticObject); 
				return; 
			case SecurityPackage.RAW_SECURITY_METRIC:
				sequence_RawSecurityMetric(context, (RawSecurityMetric) semanticObject); 
				return; 
			case SecurityPackage.RAW_SECURITY_METRIC_INSTANCE:
				sequence_RawSecurityMetricInstance(context, (RawSecurityMetricInstance) semanticObject); 
				return; 
			case SecurityPackage.SECURITY_CAPABILITY:
				sequence_SecurityCapability(context, (SecurityCapability) semanticObject); 
				return; 
			case SecurityPackage.SECURITY_CONTROL:
				sequence_SecurityControl(context, (SecurityControl) semanticObject); 
				return; 
			case SecurityPackage.SECURITY_DOMAIN:
				sequence_SecurityDomain(context, (SecurityDomain) semanticObject); 
				return; 
			case SecurityPackage.SECURITY_MODEL:
				sequence_SecurityModel(context, (SecurityModel) semanticObject); 
				return; 
			case SecurityPackage.SECURITY_PROPERTY:
				sequence_SecurityProperty_Impl(context, (SecurityProperty) semanticObject); 
				return; 
			case SecurityPackage.SECURITY_SLO:
				sequence_SecuritySLO(context, (SecuritySLO) semanticObject); 
				return; 
			}
		else if (epackage == TypePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TypePackage.BOOL_VALUE:
				sequence_BoolValue(context, (BoolValue) semanticObject); 
				return; 
			case TypePackage.BOOLEAN_VALUE_TYPE:
				sequence_BoolValueType(context, (BooleanValueType) semanticObject); 
				return; 
			case TypePackage.DOUBLE_PRECISION_VALUE:
				sequence_DoublePrecisionValue(context, (DoublePrecisionValue) semanticObject); 
				return; 
			case TypePackage.ENUMERATE_VALUE:
				sequence_EnumerateValue(context, (EnumerateValue) semanticObject); 
				return; 
			case TypePackage.ENUMERATION:
				sequence_Enumeration(context, (Enumeration) semanticObject); 
				return; 
			case TypePackage.FLOATS_VALUE:
				sequence_FloatsValue(context, (FloatsValue) semanticObject); 
				return; 
			case TypePackage.INTEGER_VALUE:
				sequence_IntegerValue(context, (IntegerValue) semanticObject); 
				return; 
			case TypePackage.LIMIT:
				sequence_Limit(context, (Limit) semanticObject); 
				return; 
			case TypePackage.LIST:
				sequence_List(context, (List) semanticObject); 
				return; 
			case TypePackage.NEGATIVE_INF:
				sequence_NegativeInf(context, (NegativeInf) semanticObject); 
				return; 
			case TypePackage.POSITIVE_INF:
				sequence_PositiveInf(context, (PositiveInf) semanticObject); 
				return; 
			case TypePackage.RANGE:
				sequence_Range(context, (Range) semanticObject); 
				return; 
			case TypePackage.RANGE_UNION:
				sequence_RangeUnion(context, (RangeUnion) semanticObject); 
				return; 
			case TypePackage.STRING_VALUE_TYPE:
				sequence_StringsValueType(context, (StringValueType) semanticObject); 
				return; 
			case TypePackage.STRINGS_VALUE:
				sequence_StringsValue(context, (StringsValue) semanticObject); 
				return; 
			case TypePackage.TYPE_MODEL:
				sequence_TypeModel(context, (TypeModel) semanticObject); 
				return; 
			case TypePackage.VALUE_TO_INCREASE:
				sequence_ValueToIncrease(context, (ValueToIncrease) semanticObject); 
				return; 
			}
		else if (epackage == UnitPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case UnitPackage.CORE_UNIT:
				sequence_CoreUnit(context, (CoreUnit) semanticObject); 
				return; 
			case UnitPackage.DIMENSIONLESS:
				sequence_Dimensionless(context, (Dimensionless) semanticObject); 
				return; 
			case UnitPackage.MONETARY_UNIT:
				sequence_MonetaryUnit(context, (MonetaryUnit) semanticObject); 
				return; 
			case UnitPackage.REQUEST_UNIT:
				sequence_RequestUnit(context, (RequestUnit) semanticObject); 
				return; 
			case UnitPackage.STORAGE_UNIT:
				sequence_StorageUnit(context, (StorageUnit) semanticObject); 
				return; 
			case UnitPackage.THROUGHPUT_UNIT:
				sequence_ThroughputUnit(context, (ThroughputUnit) semanticObject); 
				return; 
			case UnitPackage.TIME_INTERVAL_UNIT:
				sequence_TimeIntervalUnit(context, (TimeIntervalUnit) semanticObject); 
				return; 
			case UnitPackage.TRANSACTION_UNIT:
				sequence_TransactionUnit(context, (TransactionUnit) semanticObject); 
				return; 
			case UnitPackage.UNIT_MODEL:
				sequence_UnitModel(context, (UnitModel) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ActionRealisation returns ActionRealisation
	 *
	 * Constraint:
	 *     (name=ID action=[Action|Fqn] lowLevelActions=EString? startTime=EDate? endTime=EDate?)
	 */
	protected void sequence_ActionRealisation(ISerializationContext context, ActionRealisation semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Action
	 *
	 * Constraint:
	 *     (name=ID type=ActionType)
	 */
	protected void sequence_Action(ISerializationContext context, eu.paasage.camel.Action semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, CamelPackage.Literals.ACTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, CamelPackage.Literals.ACTION__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, CamelPackage.Literals.ACTION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, CamelPackage.Literals.ACTION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getActionAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getActionAccess().getTypeActionTypeEnumRuleCall_4_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Feature returns Alternative
	 *     Alternative_Impl returns Alternative
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (attributes+=Attribute attributes+=Attribute*)? 
	 *         (subFeatures+=Feature subFeatures+=Feature*)? 
	 *         featureCardinality=FeatCardinality 
	 *         (clones+=Clone clones+=Clone*)? 
	 *         groupCardinality=GroupCardinality? 
	 *         variants+=Feature 
	 *         variants+=Feature*
	 *     )
	 */
	protected void sequence_Alternative_Impl(ISerializationContext context, Alternative semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Measurement returns ApplicationMeasurement
	 *     ApplicationMeasurement returns ApplicationMeasurement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         application=[Application|Fqn] 
	 *         value=EDouble 
	 *         rawData=EString? 
	 *         eventInstance=[EventInstance|Fqn]? 
	 *         measurementTime=EDate 
	 *         executionContext=[ExecutionContext|Fqn] 
	 *         metricInstance=[MetricInstance|Fqn] 
	 *         slo=[ServiceLevelObjective|Fqn]?
	 *     )
	 */
	protected void sequence_ApplicationMeasurement(ISerializationContext context, ApplicationMeasurement semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Application returns Application
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         version=EString 
	 *         description=EString? 
	 *         owner=[Entity|Fqn] 
	 *         (deploymentModels+=[DeploymentModel|Fqn] deploymentModels+=[DeploymentModel|Fqn]*)?
	 *     )
	 */
	protected void sequence_Application(ISerializationContext context, Application semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeConstraint returns AttributeConstraint
	 *
	 * Constraint:
	 *     (from=[Attribute|Fqn] to=[Attribute|Fqn] fromValue=Value toValue=Value)
	 */
	protected void sequence_AttributeConstraint(ISerializationContext context, AttributeConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, ProviderPackage.Literals.ATTRIBUTE_CONSTRAINT__FROM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ProviderPackage.Literals.ATTRIBUTE_CONSTRAINT__FROM));
			if (transientValues.isValueTransient((EObject) semanticObject, ProviderPackage.Literals.ATTRIBUTE_CONSTRAINT__TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ProviderPackage.Literals.ATTRIBUTE_CONSTRAINT__TO));
			if (transientValues.isValueTransient((EObject) semanticObject, ProviderPackage.Literals.ATTRIBUTE_CONSTRAINT__FROM_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ProviderPackage.Literals.ATTRIBUTE_CONSTRAINT__FROM_VALUE));
			if (transientValues.isValueTransient((EObject) semanticObject, ProviderPackage.Literals.ATTRIBUTE_CONSTRAINT__TO_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ProviderPackage.Literals.ATTRIBUTE_CONSTRAINT__TO_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getAttributeConstraintAccess().getFromAttributeFqnParserRuleCall_3_0_1(), semanticObject.getFrom());
		feeder.accept(grammarAccess.getAttributeConstraintAccess().getToAttributeFqnParserRuleCall_5_0_1(), semanticObject.getTo());
		feeder.accept(grammarAccess.getAttributeConstraintAccess().getFromValueValueParserRuleCall_7_0(), semanticObject.getFromValue());
		feeder.accept(grammarAccess.getAttributeConstraintAccess().getToValueValueParserRuleCall_9_0(), semanticObject.getToValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (name=ID unitType=UnitType? value=Value? valueType=[ValueType|Fqn]?)
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EventPattern returns BinaryEventPattern
	 *     Event returns BinaryEventPattern
	 *     BinaryEventPattern returns BinaryEventPattern
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         leftEvent=[Event|Fqn]? 
	 *         rightEvent=[Event|Fqn]? 
	 *         timer=[Timer|Fqn]? 
	 *         operator=BinaryPatternOperatorType 
	 *         lowerOccurrenceBound=EInt? 
	 *         upperOccurrenceBound=EInt?
	 *     )
	 */
	protected void sequence_BinaryEventPattern(ISerializationContext context, BinaryEventPattern semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueType returns BooleanValueType
	 *     BoolValueType returns BooleanValueType
	 *
	 * Constraint:
	 *     (name=ID primitiveType=TypeEnum)
	 */
	protected void sequence_BoolValueType(ISerializationContext context, BooleanValueType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, TypePackage.Literals.VALUE_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, TypePackage.Literals.VALUE_TYPE__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, TypePackage.Literals.BOOLEAN_VALUE_TYPE__PRIMITIVE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, TypePackage.Literals.BOOLEAN_VALUE_TYPE__PRIMITIVE_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getBoolValueTypeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getBoolValueTypeAccess().getPrimitiveTypeTypeEnumEnumRuleCall_4_0(), semanticObject.getPrimitiveType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Value returns BoolValue
	 *     BoolValue returns BoolValue
	 *
	 * Constraint:
	 *     value=EBoolean
	 */
	protected void sequence_BoolValue(ISerializationContext context, BoolValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, TypePackage.Literals.BOOL_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, TypePackage.Literals.BOOL_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getBoolValueAccess().getValueEBooleanParserRuleCall_1_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CamelModel returns CamelModel
	 *
	 * Constraint:
	 *     (
	 *         importURI+=EString* 
	 *         name=ID 
	 *         (
	 *             deploymentModels+=DeploymentModel | 
	 *             executionModels+=ExecutionModel | 
	 *             locationModels+=LocationModel | 
	 *             metricModels+=MetricModel | 
	 *             organisationModels+=OrganisationModel | 
	 *             providerModels+=ProviderModel | 
	 *             requirementModels+=RequirementModel | 
	 *             scalabilityModels+=ScalabilityModel | 
	 *             securityModels+=SecurityModel | 
	 *             typeModels+=TypeModel | 
	 *             unitModels+=UnitModel | 
	 *             actions+=Action | 
	 *             applications+=Application
	 *         )*
	 *     )
	 */
	protected void sequence_CamelModel(ISerializationContext context, CamelModel semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SecurityProperty returns Certifiable
	 *     Certifiable returns Certifiable
	 *
	 * Constraint:
	 *     (name=ID description=EString? type=PropertyType (sensors+=[Sensor|Fqn] sensors+=[Sensor|Fqn]*)? domain=[SecurityDomain|Fqn])
	 */
	protected void sequence_Certifiable(ISerializationContext context, Certifiable semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clone returns Clone
	 *
	 * Constraint:
	 *     (name=ID (subClones+=[Clone|Fqn] subClones+=[Clone|Fqn]*)?)
	 */
	protected void sequence_Clone(ISerializationContext context, Clone semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CloudCredentials returns CloudCredentials
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         securityGroup=EString? 
	 *         publicSSHKey=EString? 
	 *         privateSSHKey=EString? 
	 *         username=EString? 
	 *         password=EString? 
	 *         cloudProvider=[CloudProvider|Fqn]
	 *     )
	 */
	protected void sequence_CloudCredentials(ISerializationContext context, CloudCredentials semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CloudLocation returns CloudLocation
	 *
	 * Constraint:
	 *     (
	 *         id=ID 
	 *         isAssignable?='assignable'? 
	 *         parent=[CloudLocation|Fqn]? 
	 *         geographicalRegion=[GeographicalRegion|Fqn]? 
	 *         (subLocations+=CloudLocation subLocations+=CloudLocation*)?
	 *     )
	 */
	protected void sequence_CloudLocation(ISerializationContext context, CloudLocation semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns CloudProvider
	 *     Organisation returns CloudProvider
	 *     CloudProvider returns CloudProvider
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         www=EString? 
	 *         postalAddress=EString? 
	 *         email=EString 
	 *         public?='public'? 
	 *         SaaS?='SaaS'? 
	 *         PaaS?='PaaS'? 
	 *         IaaS?='IaaS'? 
	 *         (securityCapability+=[SecurityCapability|Fqn] securityCapability+=[SecurityCapability|Fqn]*)? 
	 *         providerModel=[ProviderModel|Fqn]?
	 *     )
	 */
	protected void sequence_CloudProvider(ISerializationContext context, CloudProvider semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommunicationInstance returns CommunicationInstance
	 *
	 * Constraint:
	 *     (
	 *         requiredCommunicationInstance=[RequiredCommunicationInstance|Fqn] 
	 *         providedCommunicationInstance=[ProvidedCommunicationInstance|Fqn] 
	 *         type=[Communication|Fqn] 
	 *         name=ID?
	 *     )
	 */
	protected void sequence_CommunicationInstance(ISerializationContext context, CommunicationInstance semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Measurement returns CommunicationMeasurement
	 *     CommunicationMeasurement returns CommunicationMeasurement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         sourceVMInstance=[VMInstance|Fqn] 
	 *         destinationVMInstance=[VMInstance|Fqn] 
	 *         value=EDouble 
	 *         rawData=EString? 
	 *         eventInstance=[EventInstance|Fqn]? 
	 *         measurementTime=EDate 
	 *         executionContext=[ExecutionContext|Fqn] 
	 *         metricInstance=[MetricInstance|Fqn] 
	 *         slo=[ServiceLevelObjective|Fqn]?
	 *     )
	 */
	protected void sequence_CommunicationMeasurement(ISerializationContext context, CommunicationMeasurement semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Communication returns Communication
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         type=CommunicationType? 
	 *         requiredCommunication=[RequiredCommunication|Fqn] 
	 *         providedCommunication=[ProvidedCommunication|Fqn] 
	 *         providedPortConfiguration=Configuration? 
	 *         requiredPortConfiguration=Configuration?
	 *     )
	 */
	protected void sequence_Communication(ISerializationContext context, Communication semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionContext returns CompositeMetricContext
	 *     CompositeMetricContext returns CompositeMetricContext
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         metric=[Metric|Fqn] 
	 *         component=[Component|Fqn]? 
	 *         application=[Application|Fqn]? 
	 *         window=[Window|Fqn]? 
	 *         schedule=[Schedule|Fqn]? 
	 *         (composingMetricContexts+=[MetricContext|Fqn] composingMetricContexts+=[MetricContext|Fqn]*)? 
	 *         quantifier=QuantifierType? 
	 *         isRelative?='relative'? 
	 *         (minQuantity=EDouble maxQuantity=EDouble)?
	 *     )
	 */
	protected void sequence_CompositeMetricContext(ISerializationContext context, CompositeMetricContext semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetricInstance returns CompositeMetricInstance
	 *     CompositeMetricInstance returns CompositeMetricInstance
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         metric=[Metric|Fqn] 
	 *         objectBinding=[MetricObjectBinding|Fqn] 
	 *         composingMetricInstances+=[MetricInstance|Fqn] 
	 *         composingMetricInstances+=[MetricInstance|Fqn]* 
	 *         schedule=[Schedule|Fqn]? 
	 *         window=[Window|Fqn]? 
	 *         metricContext=[MetricContext|Fqn]?
	 *     )
	 */
	protected void sequence_CompositeMetricInstance(ISerializationContext context, CompositeMetricInstance semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CompositeMetric returns CompositeMetric
	 *     Metric returns CompositeMetric
	 *     MetricFormulaParameter returns CompositeMetric
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         description=EString? 
	 *         valueDirection=EShort? 
	 *         layer=LayerType? 
	 *         property=[Property|Fqn] 
	 *         unit=[Unit|Fqn] 
	 *         valueType=[ValueType|Fqn]? 
	 *         formula=MetricFormula
	 *     )
	 */
	protected void sequence_CompositeMetric(ISerializationContext context, CompositeMetric semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CompositeSecurityMetricInstance returns CompositeSecurityMetricInstance
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         metric=[Metric|Fqn] 
	 *         composingMetricInstances+=[MetricInstance|Fqn] 
	 *         composingMetricInstances+=[MetricInstance|Fqn]* 
	 *         objectBinding=[MetricObjectBinding|Fqn] 
	 *         schedule=[Schedule|Fqn]? 
	 *         window=[Window|Fqn]? 
	 *         metricContext=[MetricContext|Fqn]?
	 *     )
	 */
	protected void sequence_CompositeSecurityMetricInstance(ISerializationContext context, CompositeSecurityMetricInstance semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CompositeSecurityMetric returns CompositeSecurityMetric
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         description=EString? 
	 *         property=[SecurityProperty|Fqn] 
	 *         valueDirection=EShort? 
	 *         layer=LayerType? 
	 *         value=[SingleValue|Fqn]? 
	 *         valueType=[ValueType|Fqn]? 
	 *         unit=[Unit|Fqn] 
	 *         formula=MetricFormula
	 *     )
	 */
	protected void sequence_CompositeSecurityMetric(ISerializationContext context, CompositeSecurityMetric semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Configuration returns Configuration
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             downloadCommand=EString | 
	 *             uploadCommand=EString | 
	 *             installCommand=EString | 
	 *             configureCommand=EString | 
	 *             startCommand=EString | 
	 *             stopCommand=EString
	 *         )*
	 *     )
	 */
	protected void sequence_Configuration(ISerializationContext context, Configuration semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns CoreUnit
	 *     CoreUnit returns CoreUnit
	 *
	 * Constraint:
	 *     (name=ID unit=UnitType)
	 */
	protected void sequence_CoreUnit(ISerializationContext context, CoreUnit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, UnitPackage.Literals.UNIT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, UnitPackage.Literals.UNIT__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, UnitPackage.Literals.UNIT__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, UnitPackage.Literals.UNIT__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getCoreUnitAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCoreUnitAccess().getUnitUnitTypeEnumRuleCall_4_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Country returns Country
	 *
	 * Constraint:
	 *     (
	 *         id=ID 
	 *         name=EString 
	 *         (alternativeNames+=EString alternativeNames+=EString*)? 
	 *         (parentRegions+=[GeographicalRegion|Fqn] parentRegions+=[GeographicalRegion|Fqn]*)?
	 *     )
	 */
	protected void sequence_Country(ISerializationContext context, Country semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataCenter returns DataCenter
	 *
	 * Constraint:
	 *     (name=ID codeName=EString location=[Location|Fqn])
	 */
	protected void sequence_DataCenter(ISerializationContext context, DataCenter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, OrganisationPackage.Literals.DATA_CENTER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, OrganisationPackage.Literals.DATA_CENTER__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, OrganisationPackage.Literals.DATA_CENTER__CODE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, OrganisationPackage.Literals.DATA_CENTER__CODE_NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, OrganisationPackage.Literals.DATA_CENTER__LOCATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, OrganisationPackage.Literals.DATA_CENTER__LOCATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getDataCenterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDataCenterAccess().getCodeNameEStringParserRuleCall_4_0(), semanticObject.getCodeName());
		feeder.accept(grammarAccess.getDataCenterAccess().getLocationLocationFqnParserRuleCall_6_0_1(), semanticObject.getLocation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeploymentModel returns DeploymentModel
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (vms+=VM | internalComponents+=InternalComponent | vmRequirementSets+=VMRequirementSet)* 
	 *         hostings+=Hosting* 
	 *         communications+=Communication* 
	 *         vmInstances+=VMInstance? 
	 *         (internalComponentInstances+=InternalComponentInstance? vmInstances+=VMInstance?)* 
	 *         communicationInstances+=CommunicationInstance* 
	 *         hostingInstances+=HostingInstance* 
	 *         globalVMRequirementSet=[VMRequirementSet|Fqn]?
	 *     )
	 */
	protected void sequence_DeploymentModel(ISerializationContext context, DeploymentModel semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns Dimensionless
	 *     Dimensionless returns Dimensionless
	 *
	 * Constraint:
	 *     (name=ID unit=UnitType)
	 */
	protected void sequence_Dimensionless(ISerializationContext context, Dimensionless semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, UnitPackage.Literals.UNIT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, UnitPackage.Literals.UNIT__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, UnitPackage.Literals.UNIT__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, UnitPackage.Literals.UNIT__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getDimensionlessAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDimensionlessAccess().getUnitUnitTypeEnumRuleCall_4_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NumericValue returns DoublePrecisionValue
	 *     Value returns DoublePrecisionValue
	 *     DoublePrecisionValue returns DoublePrecisionValue
	 *
	 * Constraint:
	 *     value=EDouble
	 */
	protected void sequence_DoublePrecisionValue(ISerializationContext context, DoublePrecisionValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, TypePackage.Literals.DOUBLE_PRECISION_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, TypePackage.Literals.DOUBLE_PRECISION_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getDoublePrecisionValueAccess().getValueEDoubleParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Entity
	 *     Entity_Impl returns Entity
	 *
	 * Constraint:
	 *     {Entity}
	 */
	protected void sequence_Entity_Impl(ISerializationContext context, Entity semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Value returns EnumerateValue
	 *     EnumerateValue returns EnumerateValue
	 *
	 * Constraint:
	 *     (name=EString value=EInt)
	 */
	protected void sequence_EnumerateValue(ISerializationContext context, EnumerateValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, TypePackage.Literals.ENUMERATE_VALUE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, TypePackage.Literals.ENUMERATE_VALUE__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, TypePackage.Literals.ENUMERATE_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, TypePackage.Literals.ENUMERATE_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getEnumerateValueAccess().getNameEStringParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getEnumerateValueAccess().getValueEIntParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ValueType returns Enumeration
	 *     Enumeration returns Enumeration
	 *
	 * Constraint:
	 *     (name=ID values+=EnumerateValue values+=EnumerateValue*)
	 */
	protected void sequence_Enumeration(ISerializationContext context, Enumeration semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EventInstance returns EventInstance
	 *
	 * Constraint:
	 *     (name=ID event=[SimpleEvent|Fqn] status=StatusType layer=LayerType? metricInstance=[MetricInstance|Fqn]?)
	 */
	protected void sequence_EventInstance(ISerializationContext context, EventInstance semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Excludes
	 *     Excludes returns Excludes
	 *
	 * Constraint:
	 *     (name=ID from=[Feature|Fqn] to=[Feature|Fqn] (attributeConstraints+=AttributeConstraint attributeConstraints+=AttributeConstraint*)?)
	 */
	protected void sequence_Excludes(ISerializationContext context, Excludes semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Feature returns Exclusive
	 *     Exclusive returns Exclusive
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (attributes+=Attribute attributes+=Attribute*)? 
	 *         (subFeatures+=Feature subFeatures+=Feature*)? 
	 *         featureCardinality=FeatCardinality 
	 *         (clones+=Clone clones+=Clone*)? 
	 *         groupCardinality=GroupCardinality? 
	 *         variants+=Feature 
	 *         variants+=Feature*
	 *     )
	 */
	protected void sequence_Exclusive(ISerializationContext context, Exclusive semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExecutionContext returns ExecutionContext
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         startTime=EDate? 
	 *         endTime=EDate? 
	 *         totalCost=EDouble? 
	 *         application=[Application|Fqn] 
	 *         costUnit=[MonetaryUnit|Fqn]? 
	 *         deploymentModel=[DeploymentModel|Fqn] 
	 *         requirementGroup=[RequirementGroup|Fqn]
	 *     )
	 */
	protected void sequence_ExecutionContext(ISerializationContext context, ExecutionContext semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExecutionModel returns ExecutionModel
	 *
	 * Constraint:
	 *     (
	 *         (importURI+=EString importURI+=EString*)? 
	 *         name=ID 
	 *         (
	 *             actionRealisations+=ActionRealisation | 
	 *             eventInstances+=EventInstance | 
	 *             executionContexts+=ExecutionContext | 
	 *             measurements+=Measurement | 
	 *             sloAssessessments+=SLOAssessment | 
	 *             ruleTriggers+=RuleTrigger
	 *         )*
	 *     )
	 */
	protected void sequence_ExecutionModel(ISerializationContext context, ExecutionModel semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExternalIdentifier returns ExternalIdentifier
	 *
	 * Constraint:
	 *     (identifier=ID description=EString?)
	 */
	protected void sequence_ExternalIdentifier(ISerializationContext context, ExternalIdentifier semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FeatCardinality returns FeatCardinality
	 *
	 * Constraint:
	 *     (cardinalityMin=EInt cardinalityMax=EInt value=EInt?)
	 */
	protected void sequence_FeatCardinality(ISerializationContext context, FeatCardinality semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Feature returns Feature
	 *     Feature_Impl returns Feature
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (attributes+=Attribute attributes+=Attribute*)? 
	 *         (subFeatures+=Feature subFeatures+=Feature*)? 
	 *         featureCardinality=FeatCardinality 
	 *         (clones+=Clone clones+=Clone*)?
	 *     )
	 */
	protected void sequence_Feature_Impl(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NumericValue returns FloatsValue
	 *     Value returns FloatsValue
	 *     FloatsValue returns FloatsValue
	 *
	 * Constraint:
	 *     value=EFloat
	 */
	protected void sequence_FloatsValue(ISerializationContext context, FloatsValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, TypePackage.Literals.FLOATS_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, TypePackage.Literals.FLOATS_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getFloatsValueAccess().getValueEFloatParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Event returns FunctionalEvent
	 *     SimpleEvent returns FunctionalEvent
	 *     FunctionalEvent returns FunctionalEvent
	 *
	 * Constraint:
	 *     (name=ID functionalType=EString)
	 */
	protected void sequence_FunctionalEvent(ISerializationContext context, FunctionalEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, ScalabilityPackage.Literals.EVENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ScalabilityPackage.Literals.EVENT__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, ScalabilityPackage.Literals.FUNCTIONAL_EVENT__FUNCTIONAL_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ScalabilityPackage.Literals.FUNCTIONAL_EVENT__FUNCTIONAL_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getFunctionalEventAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFunctionalEventAccess().getFunctionalTypeEStringParserRuleCall_4_0(), semanticObject.getFunctionalType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Functional
	 *     Functional returns Functional
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         type=Operator? 
	 *         order=EInt? 
	 *         value=EInt 
	 *         from=[Feature|Fqn] 
	 *         to=[Feature|Fqn] 
	 *         (attributeConstraints+=AttributeConstraint attributeConstraints+=AttributeConstraint*)? 
	 *         scopeFrom=Scope? 
	 *         scopeTo=Scope? 
	 *         cardFrom=FeatCardinality? 
	 *         cardTo=FeatCardinality?
	 *     )
	 */
	protected void sequence_Functional(ISerializationContext context, Functional semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GeographicalRegion returns GeographicalRegion
	 *
	 * Constraint:
	 *     (
	 *         id=ID 
	 *         name=EString 
	 *         (alternativeNames+=EString alternativeNames+=EString*)? 
	 *         (parentRegions+=[GeographicalRegion|Fqn] parentRegions+=[GeographicalRegion|Fqn]*)?
	 *     )
	 */
	protected void sequence_GeographicalRegion(ISerializationContext context, GeographicalRegion semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GroupCardinality returns GroupCardinality
	 *
	 * Constraint:
	 *     (cardinalityMin=EInt cardinalityMax=EInt)
	 */
	protected void sequence_GroupCardinality(ISerializationContext context, GroupCardinality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, ProviderPackage.Literals.CARDINALITY__CARDINALITY_MIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ProviderPackage.Literals.CARDINALITY__CARDINALITY_MIN));
			if (transientValues.isValueTransient((EObject) semanticObject, ProviderPackage.Literals.CARDINALITY__CARDINALITY_MAX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ProviderPackage.Literals.CARDINALITY__CARDINALITY_MAX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getGroupCardinalityAccess().getCardinalityMinEIntParserRuleCall_3_0(), semanticObject.getCardinalityMin());
		feeder.accept(grammarAccess.getGroupCardinalityAccess().getCardinalityMaxEIntParserRuleCall_5_0(), semanticObject.getCardinalityMax());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Requirement returns HorizontalScaleRequirement
	 *     ScaleRequirement returns HorizontalScaleRequirement
	 *     HorizontalScaleRequirement returns HorizontalScaleRequirement
	 *
	 * Constraint:
	 *     (name=ID component=[InternalComponent|Fqn] minInstances=EInt maxInstances=EInt)
	 */
	protected void sequence_HorizontalScaleRequirement(ISerializationContext context, HorizontalScaleRequirement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, RequirementPackage.Literals.REQUIREMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, RequirementPackage.Literals.REQUIREMENT__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, RequirementPackage.Literals.HORIZONTAL_SCALE_REQUIREMENT__COMPONENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, RequirementPackage.Literals.HORIZONTAL_SCALE_REQUIREMENT__COMPONENT));
			if (transientValues.isValueTransient((EObject) semanticObject, RequirementPackage.Literals.HORIZONTAL_SCALE_REQUIREMENT__MIN_INSTANCES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, RequirementPackage.Literals.HORIZONTAL_SCALE_REQUIREMENT__MIN_INSTANCES));
			if (transientValues.isValueTransient((EObject) semanticObject, RequirementPackage.Literals.HORIZONTAL_SCALE_REQUIREMENT__MAX_INSTANCES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, RequirementPackage.Literals.HORIZONTAL_SCALE_REQUIREMENT__MAX_INSTANCES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getHorizontalScaleRequirementAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getHorizontalScaleRequirementAccess().getComponentInternalComponentFqnParserRuleCall_4_0_1(), semanticObject.getComponent());
		feeder.accept(grammarAccess.getHorizontalScaleRequirementAccess().getMinInstancesEIntParserRuleCall_6_0(), semanticObject.getMinInstances());
		feeder.accept(grammarAccess.getHorizontalScaleRequirementAccess().getMaxInstancesEIntParserRuleCall_8_0(), semanticObject.getMaxInstances());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ScalingAction returns HorizontalScalingAction
	 *     HorizontalScalingAction returns HorizontalScalingAction
	 *
	 * Constraint:
	 *     (name=ID type=ActionType vm=[VM|Fqn] internalComponent=[InternalComponent|Fqn] count=EInt?)
	 */
	protected void sequence_HorizontalScalingAction(ISerializationContext context, HorizontalScalingAction semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HostingInstance returns HostingInstance
	 *
	 * Constraint:
	 *     (requiredHostInstance=[RequiredHostInstance|Fqn] providedHostInstance=[ProvidedHostInstance|Fqn] type=[Hosting|Fqn] name=ID?)
	 */
	protected void sequence_HostingInstance(ISerializationContext context, HostingInstance semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Hosting returns Hosting
	 *
	 * Constraint:
	 *     (name=ID requiredHost=[RequiredHost|Fqn] providedHost=[ProvidedHost|Fqn])
	 */
	protected void sequence_Hosting(ISerializationContext context, Hosting semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, DeploymentPackage.Literals.DEPLOYMENT_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, DeploymentPackage.Literals.DEPLOYMENT_ELEMENT__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, DeploymentPackage.Literals.HOSTING__REQUIRED_HOST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, DeploymentPackage.Literals.HOSTING__REQUIRED_HOST));
			if (transientValues.isValueTransient((EObject) semanticObject, DeploymentPackage.Literals.HOSTING__PROVIDED_HOST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, DeploymentPackage.Literals.HOSTING__PROVIDED_HOST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getHostingAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getHostingAccess().getRequiredHostRequiredHostFqnParserRuleCall_4_0_1(), semanticObject.getRequiredHost());
		feeder.accept(grammarAccess.getHostingAccess().getProvidedHostProvidedHostFqnParserRuleCall_6_0_1(), semanticObject.getProvidedHost());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ImageRequirement returns ImageRequirement
	 *
	 * Constraint:
	 *     (name=ID imageId=EString)
	 */
	protected void sequence_ImageRequirement(ISerializationContext context, ImageRequirement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, RequirementPackage.Literals.REQUIREMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, RequirementPackage.Literals.REQUIREMENT__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, RequirementPackage.Literals.IMAGE_REQUIREMENT__IMAGE_ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, RequirementPackage.Literals.IMAGE_REQUIREMENT__IMAGE_ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getImageRequirementAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getImageRequirementAccess().getImageIdEStringParserRuleCall_4_0(), semanticObject.getImageId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Implies
	 *     Implies returns Implies
	 *
	 * Constraint:
	 *     (name=ID from=[Feature|Fqn] to=[Feature|Fqn] (attributeConstraints+=AttributeConstraint attributeConstraints+=AttributeConstraint*)?)
	 */
	protected void sequence_Implies(ISerializationContext context, Implies semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ResourceFilter returns InformationResourceFilter
	 *     InformationResourceFilter returns InformationResourceFilter
	 *
	 * Constraint:
	 *     (name=ID resourcePattern=ResourcePattern informationResourcePath=EString? everyInformationResource?='all')
	 */
	protected void sequence_InformationResourceFilter(ISerializationContext context, InformationResourceFilter semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns Instance
	 *     Instance returns Instance
	 *
	 * Constraint:
	 *     feature=[Feature|Fqn]
	 */
	protected void sequence_Instance(ISerializationContext context, Instance semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, ProviderPackage.Literals.INSTANCE__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ProviderPackage.Literals.INSTANCE__FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getInstanceAccess().getFeatureFeatureFqnParserRuleCall_3_0_1(), semanticObject.getFeature());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NumericValue returns IntegerValue
	 *     Value returns IntegerValue
	 *     IntegerValue returns IntegerValue
	 *
	 * Constraint:
	 *     value=EInt
	 */
	protected void sequence_IntegerValue(ISerializationContext context, IntegerValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, TypePackage.Literals.INTEGER_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, TypePackage.Literals.INTEGER_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getIntegerValueAccess().getValueEIntParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InternalComponentInstance returns InternalComponentInstance
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         type=[InternalComponent|Fqn] 
	 *         (
	 *             providedCommunicationInstances+=ProvidedCommunicationInstance | 
	 *             requiredCommunicationInstances+=RequiredCommunicationInstance | 
	 *             providedHostInstances+=ProvidedHostInstance | 
	 *             requiredHostInstance=RequiredHostInstance
	 *         )*
	 *     )
	 */
	protected void sequence_InternalComponentInstance(ISerializationContext context, InternalComponentInstance semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Measurement returns InternalComponentMeasurement
	 *     InternalComponentMeasurement returns InternalComponentMeasurement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         internalComponentInstance=[InternalComponentInstance|Fqn] 
	 *         value=EDouble 
	 *         rawData=EString? 
	 *         eventInstance=[EventInstance|Fqn]? 
	 *         measurementTime=EDate 
	 *         executionContext=[ExecutionContext|Fqn] 
	 *         metricInstance=[MetricInstance|Fqn] 
	 *         slo=[ServiceLevelObjective|Fqn]?
	 *     )
	 */
	protected void sequence_InternalComponentMeasurement(ISerializationContext context, InternalComponentMeasurement semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InternalComponent returns InternalComponent
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             providedCommunications+=ProvidedCommunication | 
	 *             requiredCommunications+=RequiredCommunication | 
	 *             providedHosts+=ProvidedHost | 
	 *             requiredHost=RequiredHost | 
	 *             configurations+=Configuration
	 *         )*
	 *     )
	 */
	protected void sequence_InternalComponent(ISerializationContext context, InternalComponent semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Limit returns Limit
	 *
	 * Constraint:
	 *     (value=NumericValue included?='included'?)
	 */
	protected void sequence_Limit(ISerializationContext context, Limit semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueType returns List
	 *     List returns List
	 *
	 * Constraint:
	 *     (name=ID primitiveType=TypeEnum? type=[ValueType|Fqn]? values+=Value values+=Value*)
	 */
	protected void sequence_List(ISerializationContext context, List semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LocationModel returns LocationModel
	 *
	 * Constraint:
	 *     (name=ID (regions+=GeographicalRegion | countries+=Country | cloudLocations+=CloudLocation)*)
	 */
	protected void sequence_LocationModel(ISerializationContext context, LocationModel semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Requirement returns LocationRequirement
	 *     LocationRequirement returns LocationRequirement
	 *
	 * Constraint:
	 *     (name=ID (locations+=[Location|Fqn] locations+=[Location|Fqn]*)?)
	 */
	protected void sequence_LocationRequirement(ISerializationContext context, LocationRequirement semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetricApplicationBinding returns MetricApplicationBinding
	 *     MetricObjectBinding returns MetricApplicationBinding
	 *
	 * Constraint:
	 *     (name=ID executionContext=[ExecutionContext|Fqn])
	 */
	protected void sequence_MetricApplicationBinding(ISerializationContext context, MetricApplicationBinding semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, MetricPackage.Literals.METRIC_OBJECT_BINDING__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, MetricPackage.Literals.METRIC_OBJECT_BINDING__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, MetricPackage.Literals.METRIC_OBJECT_BINDING__EXECUTION_CONTEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, MetricPackage.Literals.METRIC_OBJECT_BINDING__EXECUTION_CONTEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getMetricApplicationBindingAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMetricApplicationBindingAccess().getExecutionContextExecutionContextFqnParserRuleCall_4_0_1(), semanticObject.getExecutionContext());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MetricComponentBinding returns MetricComponentBinding
	 *     MetricObjectBinding returns MetricComponentBinding
	 *
	 * Constraint:
	 *     (name=ID executionContext=[ExecutionContext|Fqn] componentInstance=[ComponentInstance|Fqn] vmInstance=[VMInstance|Fqn]?)
	 */
	protected void sequence_MetricComponentBinding(ISerializationContext context, MetricComponentBinding semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns MetricCondition
	 *     MetricCondition returns MetricCondition
	 *
	 * Constraint:
	 *     (name=ID metricContext=[MetricContext|Fqn] threshold=EDouble comparisonOperator=ComparisonOperatorType validity=EDate?)
	 */
	protected void sequence_MetricCondition(ISerializationContext context, MetricCondition semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetricFormulaParameter returns MetricFormulaParameter
	 *     FormulaParameter returns MetricFormulaParameter
	 *     MetricFormulaParameter_Impl returns MetricFormulaParameter
	 *
	 * Constraint:
	 *     (name=ID value=[SingleValue|Fqn])
	 */
	protected void sequence_MetricFormulaParameter_Impl(ISerializationContext context, MetricFormulaParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, MetricPackage.Literals.METRIC_FORMULA_PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, MetricPackage.Literals.METRIC_FORMULA_PARAMETER__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, MetricPackage.Literals.METRIC_FORMULA_PARAMETER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, MetricPackage.Literals.METRIC_FORMULA_PARAMETER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getMetricFormulaParameter_ImplAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMetricFormulaParameter_ImplAccess().getValueSingleValueFqnParserRuleCall_4_0_1(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MetricFormulaParameter returns MetricFormula
	 *     FormulaParameter returns MetricFormula
	 *     MetricFormula returns MetricFormula
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         functionArity=MetricFunctionArityType 
	 *         functionPattern=FunctionPatternType? 
	 *         function=MetricFunctionType 
	 *         parameters+=[MetricFormulaParameter|Fqn] 
	 *         parameters+=[MetricFormulaParameter|Fqn]*
	 *     )
	 */
	protected void sequence_MetricFormula(ISerializationContext context, MetricFormula semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetricModel returns MetricModel
	 *
	 * Constraint:
	 *     (
	 *         (importURI+=EString importURI+=EString*)? 
	 *         name=ID 
	 *         (
	 *             contexts+=ConditionContext | 
	 *             metrics+=Metric | 
	 *             metricInstances+=MetricInstance | 
	 *             conditions+=Condition | 
	 *             properties+=Property | 
	 *             bindings+=MetricObjectBinding | 
	 *             windows+=Window | 
	 *             schedules+=Schedule | 
	 *             parameters+=FormulaParameter | 
	 *             sensors+=Sensor
	 *         )*
	 *     )
	 */
	protected void sequence_MetricModel(ISerializationContext context, MetricModel semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetricVMBinding returns MetricVMBinding
	 *     MetricObjectBinding returns MetricVMBinding
	 *
	 * Constraint:
	 *     (name=ID executionContext=[ExecutionContext|Fqn] vmInstance=[VMInstance|Fqn])
	 */
	protected void sequence_MetricVMBinding(ISerializationContext context, MetricVMBinding semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, MetricPackage.Literals.METRIC_OBJECT_BINDING__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, MetricPackage.Literals.METRIC_OBJECT_BINDING__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, MetricPackage.Literals.METRIC_OBJECT_BINDING__EXECUTION_CONTEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, MetricPackage.Literals.METRIC_OBJECT_BINDING__EXECUTION_CONTEXT));
			if (transientValues.isValueTransient((EObject) semanticObject, MetricPackage.Literals.METRIC_VM_BINDING__VM_INSTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, MetricPackage.Literals.METRIC_VM_BINDING__VM_INSTANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getMetricVMBindingAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMetricVMBindingAccess().getExecutionContextExecutionContextFqnParserRuleCall_4_0_1(), semanticObject.getExecutionContext());
		feeder.accept(grammarAccess.getMetricVMBindingAccess().getVmInstanceVMInstanceFqnParserRuleCall_6_0_1(), semanticObject.getVmInstance());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns MonetaryUnit
	 *     MonetaryUnit returns MonetaryUnit
	 *
	 * Constraint:
	 *     (name=ID unit=UnitType)
	 */
	protected void sequence_MonetaryUnit(ISerializationContext context, MonetaryUnit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, UnitPackage.Literals.UNIT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, UnitPackage.Literals.UNIT__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, UnitPackage.Literals.UNIT__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, UnitPackage.Literals.UNIT__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getMonetaryUnitAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMonetaryUnitAccess().getUnitUnitTypeEnumRuleCall_4_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NumericValue returns NegativeInf
	 *     Value returns NegativeInf
	 *     NegativeInf returns NegativeInf
	 *
	 * Constraint:
	 *     {NegativeInf}
	 */
	protected void sequence_NegativeInf(ISerializationContext context, NegativeInf semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns NonFunctionalEvent
	 *     SimpleEvent returns NonFunctionalEvent
	 *     NonFunctionalEvent returns NonFunctionalEvent
	 *
	 * Constraint:
	 *     (name=ID metricCondition=[MetricCondition|Fqn] isViolation?='violation')
	 */
	protected void sequence_NonFunctionalEvent(ISerializationContext context, NonFunctionalEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, ScalabilityPackage.Literals.EVENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ScalabilityPackage.Literals.EVENT__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, ScalabilityPackage.Literals.NON_FUNCTIONAL_EVENT__METRIC_CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ScalabilityPackage.Literals.NON_FUNCTIONAL_EVENT__METRIC_CONDITION));
			if (transientValues.isValueTransient((EObject) semanticObject, ScalabilityPackage.Literals.NON_FUNCTIONAL_EVENT__IS_VIOLATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ScalabilityPackage.Literals.NON_FUNCTIONAL_EVENT__IS_VIOLATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getNonFunctionalEventAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNonFunctionalEventAccess().getMetricConditionMetricConditionFqnParserRuleCall_4_0_1(), semanticObject.getMetricCondition());
		feeder.accept(grammarAccess.getNonFunctionalEventAccess().getIsViolationViolationKeyword_5_0(), semanticObject.isIsViolation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OSRequirement returns OSRequirement
	 *
	 * Constraint:
	 *     (name=ID os=EString is64os?='64os'?)
	 */
	protected void sequence_OSRequirement(ISerializationContext context, OSRequirement semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Requirement returns OptimisationRequirement
	 *     OptimisationRequirement returns OptimisationRequirement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         optimisationFunction=OptimisationFunctionType 
	 *         metric=[Metric|Fqn]? 
	 *         property=[Property|Fqn]? 
	 *         application=[Application|Fqn]? 
	 *         component=[Component|Fqn]? 
	 *         priority=EDouble?
	 *     )
	 */
	protected void sequence_OptimisationRequirement(ISerializationContext context, OptimisationRequirement semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OrganisationModel returns OrganisationModel
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         organisation=Organisation_Impl? 
	 *         provider=CloudProvider? 
	 *         (
	 *             externalIdentifiers+=ExternalIdentifier | 
	 *             users+=User | 
	 *             userGroups+=UserGroup | 
	 *             dataCentres+=DataCenter | 
	 *             roles+=Role | 
	 *             roleAssigments+=RoleAssignment | 
	 *             permissions+=Permission | 
	 *             resourceFilters+=ResourceFilter
	 *         )* 
	 *         securityLevel=SecurityLevel
	 *     )
	 */
	protected void sequence_OrganisationModel(ISerializationContext context, OrganisationModel semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Organisation
	 *     Organisation returns Organisation
	 *     Organisation_Impl returns Organisation
	 *
	 * Constraint:
	 *     (name=ID www=EString? postalAddress=EString? email=EString)
	 */
	protected void sequence_Organisation_Impl(ISerializationContext context, Organisation semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PaaSageCredentials returns PaaSageCredentials
	 *
	 * Constraint:
	 *     password=EString
	 */
	protected void sequence_PaaSageCredentials(ISerializationContext context, PaaSageCredentials semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, OrganisationPackage.Literals.PAA_SAGE_CREDENTIALS__PASSWORD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, OrganisationPackage.Literals.PAA_SAGE_CREDENTIALS__PASSWORD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getPaaSageCredentialsAccess().getPasswordEStringParserRuleCall_1_0(), semanticObject.getPassword());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Permission returns Permission
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         startTime=EDate 
	 *         endTime=EDate? 
	 *         role=[Role|Fqn] 
	 *         resourceFilter=[ResourceFilter|Fqn] 
	 *         action=ActionType
	 *     )
	 */
	protected void sequence_Permission(ISerializationContext context, Permission semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NumericValue returns PositiveInf
	 *     Value returns PositiveInf
	 *     PositiveInf returns PositiveInf
	 *
	 * Constraint:
	 *     {PositiveInf}
	 */
	protected void sequence_PositiveInf(ISerializationContext context, PositiveInf semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns Product
	 *     Product returns Product
	 *
	 * Constraint:
	 *     {Product}
	 */
	protected void sequence_Product(ISerializationContext context, Product semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns PropertyCondition
	 *     PropertyCondition returns PropertyCondition
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         propertyContext=[PropertyContext|Fqn] 
	 *         threshold=EDouble 
	 *         comparisonOperator=ComparisonOperatorType 
	 *         unit=[MonetaryUnit|Fqn]? 
	 *         timeUnit=[TimeIntervalUnit|Fqn]? 
	 *         validity=EDate?
	 *     )
	 */
	protected void sequence_PropertyCondition(ISerializationContext context, PropertyCondition semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionContext returns PropertyContext
	 *     PropertyContext returns PropertyContext
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         property=[Property|Fqn] 
	 *         component=[Component|Fqn]? 
	 *         application=[Application|Fqn]? 
	 *         quantifier=QuantifierType? 
	 *         isRelative?='relative'? 
	 *         (minQuantity=EDouble maxQuantity=EDouble)?
	 *     )
	 */
	protected void sequence_PropertyContext(ISerializationContext context, PropertyContext semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Property returns Property
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         description=EString? 
	 *         type=PropertyType 
	 *         (subProperties+=[Property|Fqn] subProperties+=[Property|Fqn]*)? 
	 *         (sensors+=[Sensor|Fqn] sensors+=[Sensor|Fqn]*)?
	 *     )
	 */
	protected void sequence_Property(ISerializationContext context, Property semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProvidedCommunicationInstance returns ProvidedCommunicationInstance
	 *
	 * Constraint:
	 *     (name=ID type=[CommunicationPort|Fqn])
	 */
	protected void sequence_ProvidedCommunicationInstance(ISerializationContext context, ProvidedCommunicationInstance semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, DeploymentPackage.Literals.DEPLOYMENT_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, DeploymentPackage.Literals.DEPLOYMENT_ELEMENT__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, DeploymentPackage.Literals.COMMUNICATION_PORT_INSTANCE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, DeploymentPackage.Literals.COMMUNICATION_PORT_INSTANCE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getProvidedCommunicationInstanceAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getProvidedCommunicationInstanceAccess().getTypeCommunicationPortFqnParserRuleCall_3_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ProvidedCommunication returns ProvidedCommunication
	 *
	 * Constraint:
	 *     (name=ID portNumber=INT*)
	 */
	protected void sequence_ProvidedCommunication(ISerializationContext context, ProvidedCommunication semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProvidedHostInstance returns ProvidedHostInstance
	 *
	 * Constraint:
	 *     (name=ID type=[HostingPort|Fqn])
	 */
	protected void sequence_ProvidedHostInstance(ISerializationContext context, ProvidedHostInstance semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, DeploymentPackage.Literals.DEPLOYMENT_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, DeploymentPackage.Literals.DEPLOYMENT_ELEMENT__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, DeploymentPackage.Literals.HOSTING_PORT_INSTANCE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, DeploymentPackage.Literals.HOSTING_PORT_INSTANCE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getProvidedHostInstanceAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getProvidedHostInstanceAccess().getTypeHostingPortFqnParserRuleCall_3_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ProvidedHost returns ProvidedHost
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ProvidedHost(ISerializationContext context, ProvidedHost semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, DeploymentPackage.Literals.DEPLOYMENT_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, DeploymentPackage.Literals.DEPLOYMENT_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getProvidedHostAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ProviderModel returns ProviderModel
	 *
	 * Constraint:
	 *     (name=ID (constraints+=Constraint constraints+=Constraint*)? rootFeature=Feature)
	 */
	protected void sequence_ProviderModel(ISerializationContext context, ProviderModel semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProviderRequirement returns ProviderRequirement
	 *
	 * Constraint:
	 *     (name=ID providers+=[CloudProvider|Fqn] providers+=[CloudProvider|Fqn]*)
	 */
	protected void sequence_ProviderRequirement(ISerializationContext context, ProviderRequirement semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     QualitativeHardwareRequirement returns QualitativeHardwareRequirement
	 *
	 * Constraint:
	 *     (name=ID minBenchmark=Double maxBenchmark=Double?)
	 */
	protected void sequence_QualitativeHardwareRequirement(ISerializationContext context, QualitativeHardwareRequirement semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     QuantitativeHardwareRequirement returns QuantitativeHardwareRequirement
	 *
	 * Constraint:
	 *     (name=ID (minCores=INT maxCores=INT?)? (minRAM=INT maxRAM=INT?)? (minStorage=INT maxStorage=INT?)? (minCPU=Double maxCPU=Double?)?)
	 */
	protected void sequence_QuantitativeHardwareRequirement(ISerializationContext context, QuantitativeHardwareRequirement semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueType returns RangeUnion
	 *     RangeUnion returns RangeUnion
	 *
	 * Constraint:
	 *     (name=ID primitiveType=TypeEnum ranges+=Range ranges+=Range*)
	 */
	protected void sequence_RangeUnion(ISerializationContext context, RangeUnion semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueType returns Range
	 *     Range returns Range
	 *
	 * Constraint:
	 *     (name=ID primitiveType=TypeEnum lowerLimit=Limit upperLimit=Limit)
	 */
	protected void sequence_Range(ISerializationContext context, Range semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, TypePackage.Literals.VALUE_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, TypePackage.Literals.VALUE_TYPE__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, TypePackage.Literals.RANGE__PRIMITIVE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, TypePackage.Literals.RANGE__PRIMITIVE_TYPE));
			if (transientValues.isValueTransient((EObject) semanticObject, TypePackage.Literals.RANGE__LOWER_LIMIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, TypePackage.Literals.RANGE__LOWER_LIMIT));
			if (transientValues.isValueTransient((EObject) semanticObject, TypePackage.Literals.RANGE__UPPER_LIMIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, TypePackage.Literals.RANGE__UPPER_LIMIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getRangeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRangeAccess().getPrimitiveTypeTypeEnumEnumRuleCall_4_0(), semanticObject.getPrimitiveType());
		feeder.accept(grammarAccess.getRangeAccess().getLowerLimitLimitParserRuleCall_6_0(), semanticObject.getLowerLimit());
		feeder.accept(grammarAccess.getRangeAccess().getUpperLimitLimitParserRuleCall_8_0(), semanticObject.getUpperLimit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConditionContext returns RawMetricContext
	 *     RawMetricContext returns RawMetricContext
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         metric=[Metric|Fqn] 
	 *         sensor=[Sensor|Fqn] 
	 *         component=[Component|Fqn]? 
	 *         application=[Application|Fqn]? 
	 *         window=[Window|Fqn]? 
	 *         schedule=[Schedule|Fqn]? 
	 *         quantifier=QuantifierType? 
	 *         isRelative?='relative'? 
	 *         (minQuantity=EDouble maxQuantity=EDouble)?
	 *     )
	 */
	protected void sequence_RawMetricContext(ISerializationContext context, RawMetricContext semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetricInstance returns RawMetricInstance
	 *     RawMetricInstance returns RawMetricInstance
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         metric=[Metric|Fqn] 
	 *         sensor=[Sensor|Fqn] 
	 *         objectBinding=[MetricObjectBinding|Fqn] 
	 *         schedule=[Schedule|Fqn]? 
	 *         window=[Window|Fqn]? 
	 *         metricContext=[MetricContext|Fqn]?
	 *     )
	 */
	protected void sequence_RawMetricInstance(ISerializationContext context, RawMetricInstance semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RawMetric returns RawMetric
	 *     Metric returns RawMetric
	 *     MetricFormulaParameter returns RawMetric
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         description=EString? 
	 *         valueDirection=EShort? 
	 *         layer=LayerType? 
	 *         property=[Property|Fqn] 
	 *         unit=[Unit|Fqn] 
	 *         valueType=[ValueType|Fqn]?
	 *     )
	 */
	protected void sequence_RawMetric(ISerializationContext context, RawMetric semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RawSecurityMetricInstance returns RawSecurityMetricInstance
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         metric=[Metric|Fqn] 
	 *         sensor=[Sensor|Fqn] 
	 *         objectBinding=[MetricObjectBinding|Fqn] 
	 *         schedule=[Schedule|Fqn]? 
	 *         window=[Window|Fqn]? 
	 *         metricContext=[MetricContext|Fqn]?
	 *     )
	 */
	protected void sequence_RawSecurityMetricInstance(ISerializationContext context, RawSecurityMetricInstance semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RawSecurityMetric returns RawSecurityMetric
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         description=EString? 
	 *         property=[SecurityProperty|Fqn] 
	 *         valueDirection=EShort? 
	 *         layer=LayerType? 
	 *         value=[SingleValue|Fqn]? 
	 *         valueType=[ValueType|Fqn]? 
	 *         unit=[Unit|Fqn]
	 *     )
	 */
	protected void sequence_RawSecurityMetric(ISerializationContext context, RawSecurityMetric semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns RequestUnit
	 *     RequestUnit returns RequestUnit
	 *
	 * Constraint:
	 *     (name=ID unit=UnitType)
	 */
	protected void sequence_RequestUnit(ISerializationContext context, RequestUnit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, UnitPackage.Literals.UNIT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, UnitPackage.Literals.UNIT__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, UnitPackage.Literals.UNIT__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, UnitPackage.Literals.UNIT__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getRequestUnitAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRequestUnitAccess().getUnitUnitTypeEnumRuleCall_4_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RequiredCommunicationInstance returns RequiredCommunicationInstance
	 *
	 * Constraint:
	 *     (name=ID type=[CommunicationPort|Fqn])
	 */
	protected void sequence_RequiredCommunicationInstance(ISerializationContext context, RequiredCommunicationInstance semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, DeploymentPackage.Literals.DEPLOYMENT_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, DeploymentPackage.Literals.DEPLOYMENT_ELEMENT__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, DeploymentPackage.Literals.COMMUNICATION_PORT_INSTANCE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, DeploymentPackage.Literals.COMMUNICATION_PORT_INSTANCE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getRequiredCommunicationInstanceAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRequiredCommunicationInstanceAccess().getTypeCommunicationPortFqnParserRuleCall_3_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RequiredCommunication returns RequiredCommunication
	 *
	 * Constraint:
	 *     (name=ID (portNumber=INT | isMandatory?='mandatory')*)
	 */
	protected void sequence_RequiredCommunication(ISerializationContext context, RequiredCommunication semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RequiredHostInstance returns RequiredHostInstance
	 *
	 * Constraint:
	 *     (name=ID type=[HostingPort|Fqn])
	 */
	protected void sequence_RequiredHostInstance(ISerializationContext context, RequiredHostInstance semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, DeploymentPackage.Literals.DEPLOYMENT_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, DeploymentPackage.Literals.DEPLOYMENT_ELEMENT__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, DeploymentPackage.Literals.HOSTING_PORT_INSTANCE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, DeploymentPackage.Literals.HOSTING_PORT_INSTANCE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getRequiredHostInstanceAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRequiredHostInstanceAccess().getTypeHostingPortFqnParserRuleCall_3_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RequiredHost returns RequiredHost
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_RequiredHost(ISerializationContext context, RequiredHost semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, DeploymentPackage.Literals.DEPLOYMENT_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, DeploymentPackage.Literals.DEPLOYMENT_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getRequiredHostAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RequirementGroup returns RequirementGroup
	 *     Requirement returns RequirementGroup
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         requirementOperator=RequirementOperatorType 
	 *         requirements+=[Requirement|Fqn] 
	 *         requirements+=[Requirement|Fqn]* 
	 *         (application+=[Application|Fqn] application+=[Application|Fqn]*)?
	 *     )
	 */
	protected void sequence_RequirementGroup(ISerializationContext context, RequirementGroup semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RequirementModel returns RequirementModel
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             requirements+=LocationRequirement | 
	 *             requirements+=QuantitativeHardwareRequirement | 
	 *             requirements+=QualitativeHardwareRequirement | 
	 *             requirements+=ImageRequirement | 
	 *             requirements+=OSRequirement | 
	 *             requirements+=HorizontalScaleRequirement | 
	 *             requirements+=VerticalScaleRequirement | 
	 *             requirements+=SecurityRequirement | 
	 *             requirements+=ServiceLevelObjective | 
	 *             requirements+=OptimisationRequirement | 
	 *             requirements+=ProviderRequirement | 
	 *             requirements+=RequirementGroup
	 *         )*
	 *     )
	 */
	protected void sequence_RequirementModel(ISerializationContext context, RequirementModel semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Requires
	 *     Requires_Impl returns Requires
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         from=[Feature|Fqn] 
	 *         to=[Feature|Fqn] 
	 *         (attributeConstraints+=AttributeConstraint attributeConstraints+=AttributeConstraint*)? 
	 *         scopeFrom=Scope? 
	 *         scopeTo=Scope? 
	 *         cardFrom=FeatCardinality? 
	 *         cardTo=FeatCardinality?
	 *     )
	 */
	protected void sequence_Requires_Impl(ISerializationContext context, Requires semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RoleAssignment returns RoleAssignment
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         startTime=EDate? 
	 *         endTime=EDate? 
	 *         assignmentTime=EDate 
	 *         user=[User|Fqn]? 
	 *         role=[Role|Fqn] 
	 *         userGroup=[UserGroup|Fqn]?
	 *     )
	 */
	protected void sequence_RoleAssignment(ISerializationContext context, RoleAssignment semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Role returns Role
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Role(ISerializationContext context, Role semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, OrganisationPackage.Literals.ROLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, OrganisationPackage.Literals.ROLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getRoleAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RuleTrigger returns RuleTrigger
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         scalabilityRule=[ScalabilityRule|Fqn] 
	 *         trigerringTime=EDate 
	 *         actionRealisations+=[ActionRealisation|Fqn] 
	 *         actionRealisations+=[ActionRealisation|Fqn]* 
	 *         executionContext=[ExecutionContext|Fqn] 
	 *         eventInstances+=[EventInstance|Fqn] 
	 *         eventInstances+=[EventInstance|Fqn]*
	 *     )
	 */
	protected void sequence_RuleTrigger(ISerializationContext context, RuleTrigger semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SLOAssessment returns SLOAssessment
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         measurement=[Measurement|Fqn] 
	 *         executionContext=[ExecutionContext|Fqn] 
	 *         assessmentTime=EDate 
	 *         slo=[ServiceLevelObjective|Fqn] 
	 *         assessment?='violated'
	 *     )
	 */
	protected void sequence_SLOAssessment(ISerializationContext context, SLOAssessment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, ExecutionPackage.Literals.SLO_ASSESSMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ExecutionPackage.Literals.SLO_ASSESSMENT__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, ExecutionPackage.Literals.SLO_ASSESSMENT__MEASUREMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ExecutionPackage.Literals.SLO_ASSESSMENT__MEASUREMENT));
			if (transientValues.isValueTransient((EObject) semanticObject, ExecutionPackage.Literals.SLO_ASSESSMENT__EXECUTION_CONTEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ExecutionPackage.Literals.SLO_ASSESSMENT__EXECUTION_CONTEXT));
			if (transientValues.isValueTransient((EObject) semanticObject, ExecutionPackage.Literals.SLO_ASSESSMENT__ASSESSMENT_TIME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ExecutionPackage.Literals.SLO_ASSESSMENT__ASSESSMENT_TIME));
			if (transientValues.isValueTransient((EObject) semanticObject, ExecutionPackage.Literals.SLO_ASSESSMENT__SLO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ExecutionPackage.Literals.SLO_ASSESSMENT__SLO));
			if (transientValues.isValueTransient((EObject) semanticObject, ExecutionPackage.Literals.SLO_ASSESSMENT__ASSESSMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, ExecutionPackage.Literals.SLO_ASSESSMENT__ASSESSMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getSLOAssessmentAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSLOAssessmentAccess().getMeasurementMeasurementFqnParserRuleCall_4_0_1(), semanticObject.getMeasurement());
		feeder.accept(grammarAccess.getSLOAssessmentAccess().getExecutionContextExecutionContextFqnParserRuleCall_6_0_1(), semanticObject.getExecutionContext());
		feeder.accept(grammarAccess.getSLOAssessmentAccess().getAssessmentTimeEDateParserRuleCall_8_0(), semanticObject.getAssessmentTime());
		feeder.accept(grammarAccess.getSLOAssessmentAccess().getSloServiceLevelObjectiveFqnParserRuleCall_10_0_1(), semanticObject.getSlo());
		feeder.accept(grammarAccess.getSLOAssessmentAccess().getAssessmentViolatedKeyword_11_0(), semanticObject.isAssessment());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ScalabilityModel returns ScalabilityModel
	 *
	 * Constraint:
	 *     (
	 *         (importURI+=EString importURI+=EString*)? 
	 *         name=ID 
	 *         (
	 *             rules+=ScalabilityRule | 
	 *             events+=Event | 
	 *             eventInstances+=EventInstance | 
	 *             actions+=ScalingAction | 
	 *             timers+=Timer | 
	 *             scaleRequirements+=ScaleRequirement
	 *         )*
	 *     )
	 */
	protected void sequence_ScalabilityModel(ISerializationContext context, ScalabilityModel semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ScalabilityRule returns ScalabilityRule
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         event=[Event|Fqn] 
	 *         actions+=[Action|Fqn] 
	 *         actions+=[Action|Fqn]* 
	 *         (entity+=[Entity|Fqn] entity+=[Entity|Fqn]*)? 
	 *         (scaleRequirements+=[ScaleRequirement|Fqn] scaleRequirements+=[ScaleRequirement|Fqn]*)?
	 *     )
	 */
	protected void sequence_ScalabilityRule(ISerializationContext context, ScalabilityRule semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Schedule returns Schedule
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         type=ScheduleType 
	 *         interval=ELong 
	 *         unit=[TimeIntervalUnit|Fqn] 
	 *         start=EDate? 
	 *         end=EDate? 
	 *         repetitions=EInt?
	 *     )
	 */
	protected void sequence_Schedule(ISerializationContext context, Schedule semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SecurityCapability returns SecurityCapability
	 *
	 * Constraint:
	 *     (name=ID securityControls+=[SecurityControl|Fqn] securityControls+=[SecurityControl|Fqn]* dataCenter=[DataCenter|Fqn]?)
	 */
	protected void sequence_SecurityCapability(ISerializationContext context, SecurityCapability semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SecurityControl returns SecurityControl
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         specification=EString 
	 *         domain=[SecurityDomain|Fqn] 
	 *         subDomain=[SecurityDomain|Fqn] 
	 *         (securityProperties+=[SecurityProperty|Fqn] securityProperties+=[SecurityProperty|Fqn]*)? 
	 *         (rawSecurityMetrics+=[RawSecurityMetric|Fqn] rawSecurityMetrics+=[RawSecurityMetric|Fqn]*)? 
	 *         (compositeSecurityMetrics+=[CompositeSecurityMetric|Fqn] compositeSecurityMetrics+=[CompositeSecurityMetric|Fqn]*)?
	 *     )
	 */
	protected void sequence_SecurityControl(ISerializationContext context, SecurityControl semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SecurityDomain returns SecurityDomain
	 *
	 * Constraint:
	 *     (id=ID name=EString (subDomain+=[SecurityDomain|Fqn] subDomain+=[SecurityDomain|Fqn]*)?)
	 */
	protected void sequence_SecurityDomain(ISerializationContext context, SecurityDomain semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SecurityModel returns SecurityModel
	 *
	 * Constraint:
	 *     (
	 *         (importURI+=EString importURI+=EString*)? 
	 *         name=ID 
	 *         (
	 *             securityControls+=SecurityControl | 
	 *             securityProperties+=SecurityProperty | 
	 *             rawSecurityMetrics+=RawSecurityMetric | 
	 *             compositeSecurityMetrics+=CompositeSecurityMetric | 
	 *             rawSecurityMetricInstances+=RawSecurityMetricInstance | 
	 *             compositeSecurityMetricInstances+=CompositeSecurityMetricInstance | 
	 *             securityDomains+=SecurityDomain | 
	 *             securityCapabilities+=SecurityCapability | 
	 *             securitySLOs+=SecuritySLO
	 *         )*
	 *     )
	 */
	protected void sequence_SecurityModel(ISerializationContext context, SecurityModel semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SecurityProperty returns SecurityProperty
	 *     SecurityProperty_Impl returns SecurityProperty
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         description=EString? 
	 *         type=PropertyType 
	 *         (subProperties+=[SecurityProperty|Fqn] subProperties+=[SecurityProperty|Fqn]*)? 
	 *         (sensors+=[Sensor|Fqn] sensors+=[Sensor|Fqn]*)? 
	 *         domain=[SecurityDomain|Fqn]
	 *     )
	 */
	protected void sequence_SecurityProperty_Impl(ISerializationContext context, SecurityProperty semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Requirement returns SecurityRequirement
	 *     SecurityRequirement returns SecurityRequirement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         securityControls+=[SecurityControl|Fqn] 
	 *         securityControls+=[SecurityControl|Fqn]* 
	 *         application=[Application|Fqn]? 
	 *         component=[InternalComponent|Fqn]?
	 *     )
	 */
	protected void sequence_SecurityRequirement(ISerializationContext context, SecurityRequirement semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SecuritySLO returns SecuritySLO
	 *
	 * Constraint:
	 *     (name=ID customServiceLevel=[Condition|Fqn])
	 */
	protected void sequence_SecuritySLO(ISerializationContext context, SecuritySLO semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, RequirementPackage.Literals.REQUIREMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, RequirementPackage.Literals.REQUIREMENT__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, RequirementPackage.Literals.SERVICE_LEVEL_OBJECTIVE__CUSTOM_SERVICE_LEVEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, RequirementPackage.Literals.SERVICE_LEVEL_OBJECTIVE__CUSTOM_SERVICE_LEVEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getSecuritySLOAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSecuritySLOAccess().getCustomServiceLevelConditionFqnParserRuleCall_4_0_1(), semanticObject.getCustomServiceLevel());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sensor returns Sensor
	 *
	 * Constraint:
	 *     (name=ID configuration=EString? isPush?='push'?)
	 */
	protected void sequence_Sensor(ISerializationContext context, Sensor semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Requirement returns ServiceLevelObjective
	 *     ServiceLevelObjective returns ServiceLevelObjective
	 *
	 * Constraint:
	 *     (name=ID customServiceLevel=[Condition|Fqn])
	 */
	protected void sequence_ServiceLevelObjective(ISerializationContext context, ServiceLevelObjective semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, RequirementPackage.Literals.REQUIREMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, RequirementPackage.Literals.REQUIREMENT__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, RequirementPackage.Literals.SERVICE_LEVEL_OBJECTIVE__CUSTOM_SERVICE_LEVEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, RequirementPackage.Literals.SERVICE_LEVEL_OBJECTIVE__CUSTOM_SERVICE_LEVEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getServiceLevelObjectiveAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getServiceLevelObjectiveAccess().getCustomServiceLevelConditionFqnParserRuleCall_4_0_1(), semanticObject.getCustomServiceLevel());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ResourceFilter returns ServiceResourceFilter
	 *     ServiceResourceFilter returns ServiceResourceFilter
	 *
	 * Constraint:
	 *     (name=ID resourcePattern=ResourcePattern serviceURL=EString? everyService?='all')
	 */
	protected void sequence_ServiceResourceFilter(ISerializationContext context, ServiceResourceFilter semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns StorageUnit
	 *     StorageUnit returns StorageUnit
	 *
	 * Constraint:
	 *     (name=ID unit=UnitType)
	 */
	protected void sequence_StorageUnit(ISerializationContext context, StorageUnit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, UnitPackage.Literals.UNIT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, UnitPackage.Literals.UNIT__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, UnitPackage.Literals.UNIT__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, UnitPackage.Literals.UNIT__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getStorageUnitAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getStorageUnitAccess().getUnitUnitTypeEnumRuleCall_4_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ValueType returns StringValueType
	 *     StringsValueType returns StringValueType
	 *
	 * Constraint:
	 *     (name=ID primitiveType=TypeEnum)
	 */
	protected void sequence_StringsValueType(ISerializationContext context, StringValueType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, TypePackage.Literals.VALUE_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, TypePackage.Literals.VALUE_TYPE__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, TypePackage.Literals.STRING_VALUE_TYPE__PRIMITIVE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, TypePackage.Literals.STRING_VALUE_TYPE__PRIMITIVE_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getStringsValueTypeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getStringsValueTypeAccess().getPrimitiveTypeTypeEnumEnumRuleCall_4_0(), semanticObject.getPrimitiveType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Value returns StringsValue
	 *     StringsValue returns StringsValue
	 *
	 * Constraint:
	 *     value=EString
	 */
	protected void sequence_StringsValue(ISerializationContext context, StringsValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, TypePackage.Literals.STRINGS_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, TypePackage.Literals.STRINGS_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getStringsValueAccess().getValueEStringParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns ThroughputUnit
	 *     ThroughputUnit returns ThroughputUnit
	 *
	 * Constraint:
	 *     (name=ID unit=UnitType)
	 */
	protected void sequence_ThroughputUnit(ISerializationContext context, ThroughputUnit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, UnitPackage.Literals.UNIT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, UnitPackage.Literals.UNIT__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, UnitPackage.Literals.UNIT__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, UnitPackage.Literals.UNIT__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getThroughputUnitAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getThroughputUnitAccess().getUnitUnitTypeEnumRuleCall_4_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns TimeIntervalUnit
	 *     TimeIntervalUnit returns TimeIntervalUnit
	 *
	 * Constraint:
	 *     (name=ID unit=UnitType)
	 */
	protected void sequence_TimeIntervalUnit(ISerializationContext context, TimeIntervalUnit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, UnitPackage.Literals.UNIT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, UnitPackage.Literals.UNIT__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, UnitPackage.Literals.UNIT__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, UnitPackage.Literals.UNIT__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getTimeIntervalUnitAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTimeIntervalUnitAccess().getUnitUnitTypeEnumRuleCall_4_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Timer returns Timer
	 *
	 * Constraint:
	 *     (name=ID type=TimerType timeValue=EInt unit=[TimeIntervalUnit|Fqn] maxOccurrenceNum=EInt?)
	 */
	protected void sequence_Timer(ISerializationContext context, Timer semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns TransactionUnit
	 *     TransactionUnit returns TransactionUnit
	 *
	 * Constraint:
	 *     (name=ID unit=UnitType)
	 */
	protected void sequence_TransactionUnit(ISerializationContext context, TransactionUnit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, UnitPackage.Literals.UNIT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, UnitPackage.Literals.UNIT__NAME));
			if (transientValues.isValueTransient((EObject) semanticObject, UnitPackage.Literals.UNIT__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, UnitPackage.Literals.UNIT__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getTransactionUnitAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTransactionUnitAccess().getUnitUnitTypeEnumRuleCall_4_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeModel returns TypeModel
	 *
	 * Constraint:
	 *     ((importURI+=EString importURI+=EString*)? name=ID (dataTypes+=ValueType | values+=Value)*)
	 */
	protected void sequence_TypeModel(ISerializationContext context, TypeModel semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EventPattern returns UnaryEventPattern
	 *     Event returns UnaryEventPattern
	 *     UnaryEventPattern returns UnaryEventPattern
	 *
	 * Constraint:
	 *     (name=ID event=[Event|Fqn] operator=UnaryPatternOperatorType timer=[Timer|Fqn]? occurrenceNum=EInt?)
	 */
	protected void sequence_UnaryEventPattern(ISerializationContext context, UnaryEventPattern semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitModel returns UnitModel
	 *
	 * Constraint:
	 *     (name=ID units+=Unit*)
	 */
	protected void sequence_UnitModel(ISerializationContext context, UnitModel semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UserGroup returns UserGroup
	 *
	 * Constraint:
	 *     (name=ID users+=[User|Fqn] users+=[User|Fqn]*)
	 */
	protected void sequence_UserGroup(ISerializationContext context, UserGroup semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns User
	 *     User returns User
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         firstName=EString 
	 *         lastName=EString 
	 *         email=EString 
	 *         www=EString? 
	 *         paasageCredentials=PaaSageCredentials 
	 *         (cloudCredentials+=CloudCredentials cloudCredentials+=CloudCredentials*)? 
	 *         (externalIdentifiers+=ExternalIdentifier externalIdentifiers+=ExternalIdentifier*)? 
	 *         (requirementModels+=[RequirementModel|Fqn] requirementModels+=[RequirementModel|Fqn]*)? 
	 *         (deploymentModels+=[DeploymentModel|Fqn] deploymentModels+=[DeploymentModel|Fqn]*)?
	 *     )
	 */
	protected void sequence_User(ISerializationContext context, User semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VMInstance returns VMInstance
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         type=[VM|Fqn] 
	 *         ip=EString? 
	 *         vmType=[Attribute|Fqn]? 
	 *         vmTypeValue=[SingleValue|Fqn]? 
	 *         providedHostInstances+=ProvidedHostInstance*
	 *     )
	 */
	protected void sequence_VMInstance(ISerializationContext context, VMInstance semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Measurement returns VMMeasurement
	 *     VMMeasurement returns VMMeasurement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         vmInstance=[VMInstance|Fqn] 
	 *         value=EDouble 
	 *         rawData=EString? 
	 *         eventInstance=[EventInstance|Fqn]? 
	 *         measurementTime=EDate 
	 *         executionContext=[ExecutionContext|Fqn] 
	 *         metricInstance=[MetricInstance|Fqn] 
	 *         slo=[ServiceLevelObjective|Fqn]?
	 *     )
	 */
	protected void sequence_VMMeasurement(ISerializationContext context, VMMeasurement semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VMRequirementSet returns VMRequirementSet
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             locationRequirement=[LocationRequirement|Fqn] | 
	 *             qualitativeHardwareRequirement=[QualitativeHardwareRequirement|Fqn] | 
	 *             quantitativeHardwareRequirement=[QuantitativeHardwareRequirement|Fqn] | 
	 *             osOrImageRequirement=[OSRequirement|Fqn] | 
	 *             osOrImageRequirement=[ImageRequirement|Fqn] | 
	 *             providerRequirement=[ProviderRequirement|Fqn]
	 *         )*
	 *     )
	 */
	protected void sequence_VMRequirementSet(ISerializationContext context, VMRequirementSet semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VM returns VM
	 *
	 * Constraint:
	 *     (name=ID vmRequirementSet=[VMRequirementSet|ID]? (providedHosts+=ProvidedHost | configurations+=Configuration)*)
	 */
	protected void sequence_VM(ISerializationContext context, VM semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NumericValue returns ValueToIncrease
	 *     Value returns ValueToIncrease
	 *     ValueToIncrease returns ValueToIncrease
	 *
	 * Constraint:
	 *     value=NumericValue
	 */
	protected void sequence_ValueToIncrease(ISerializationContext context, ValueToIncrease semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, TypePackage.Literals.VALUE_TO_INCREASE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, TypePackage.Literals.VALUE_TO_INCREASE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getValueToIncreaseAccess().getValueNumericValueParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Requirement returns VerticalScaleRequirement
	 *     ScaleRequirement returns VerticalScaleRequirement
	 *     VerticalScaleRequirement returns VerticalScaleRequirement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         vm=[VM|Fqn] 
	 *         (minCores=INT maxCores=INT?)? 
	 *         (minRAM=INT maxRAM=INT?)? 
	 *         (minStorage=INT maxStorage=INT?)? 
	 *         (minCPU=Double maxCPU=Double?)?
	 *     )
	 */
	protected void sequence_VerticalScaleRequirement(ISerializationContext context, VerticalScaleRequirement semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ScalingAction returns VerticalScalingAction
	 *     VerticalScalingAction returns VerticalScalingAction
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         type=ActionType 
	 *         vm=[VM|Fqn] 
	 *         coreUpdate=EInt? 
	 *         CPUUpdate=EDouble? 
	 *         memoryUpdate=EInt? 
	 *         storageUpdate=EInt? 
	 *         ioUpdate=EInt? 
	 *         networkUpdate=EInt?
	 *     )
	 */
	protected void sequence_VerticalScalingAction(ISerializationContext context, VerticalScalingAction semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Window returns Window
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         windowType=WindowType 
	 *         sizeType=WindowSizeType 
	 *         measurementSize=ELong? 
	 *         timeSize=ELong? 
	 *         unit=[TimeIntervalUnit|Fqn]?
	 *     )
	 */
	protected void sequence_Window(ISerializationContext context, Window semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
}
